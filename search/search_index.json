{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jeka \u00b6 Jeka is a general purpose build tool, that is designed as a library + an automation engine. Users simply write build logic in Java or Kotlin, then they can invoke their code directly from the command line : Java/Kotlin classes become first class citizen build-scripts !!! This approach provides several benefits developers love : flexibility, lightweight, transparency, discoverability and extendability. Beside, Jeka tries to keep cognitive load low, introducing a minimal set of concepts. Good skills in Java/Kotiln should be enough to achive builds of any complexity. Last but not least, Jeka is very lightweight (less than 1Mb) and has zero dependencies, making it friendly to be used as a simple library.","title":"Welcome to Jeka"},{"location":"#welcome-to-jeka","text":"Jeka is a general purpose build tool, that is designed as a library + an automation engine. Users simply write build logic in Java or Kotlin, then they can invoke their code directly from the command line : Java/Kotlin classes become first class citizen build-scripts !!! This approach provides several benefits developers love : flexibility, lightweight, transparency, discoverability and extendability. Beside, Jeka tries to keep cognitive load low, introducing a minimal set of concepts. Good skills in Java/Kotiln should be enough to achive builds of any complexity. Last but not least, Jeka is very lightweight (less than 1Mb) and has zero dependencies, making it friendly to be used as a simple library.","title":"Welcome to Jeka"},{"location":"cheat-sheet/","text":"Useful commands \u00b6 Jeka has predefined methods that comes either from JkClass or built-in plugins. jeka : Displays on console methods and options invokable from command line, along with plugins available in the classpath. jeka [kbean-name]#help : Displays on console methods and options invokable for the specified plugin (e.g. jeka scaffold#help ). jeka intellij#iml : Generates iml file for Intellij. It is generated accordingly the dependencies that is declared for Jeka project. jeka intellij#iml -JKC= : If the jeka intellij#iml fails due to the non-compile def classes, -JKC= will avoid def compilation phase. jeka eclipse#files : Same purpose as above to generate metadata files for Eclipse. jeka scaffold#run : Generates files for creating a basic Jeka project from scratch. jeka scaffold#wrapper : Generates wrapper files (jekaw/jekaw.bat and bootstrap jar). jeka scaffold#run java# : Generates files for creating a Jeka a project to build a JVM language project. Useful standard options \u00b6 You can add the below options to the command line. -kb=[KBeanName] : By default, Jeka instantiates the first KBean that is found under def directory to execute methods. It can be forced to instantiate a specific class by passing its long or short name. If the class is already in classpath, then no def compilation occurs. Simply, -JKC= is equivalent to -JKC=JkClass which is the base class bundled in Jeka . -lri : Displays runtime info which will be displayed meaningfully on console about current Jeka version, Java version, base directory, download repository, classpath, ... -lsu : Shows logs about Jeka setup (compilation of def classes, plugin loading, ...). This information is not logged by default. -ls=BRACE : Alters console output by delimiting tasks with braces and mentioning the processing time for each task. -ls=DEBUG : Alters console output by showing the class name and line number where the log has been emitted. -lv : Alters console output by displaying trace logs (emitted by JkLog#trace ). -cw : Clean .work directory, forcing compilation of def classes, even if it is marked as up-to-date. Change the JDK that Runs Jeka \u00b6 To determine the JDK to run upon, Jeka looks in priority order at : JEKA_JDK environment variable ([ JEKA_JDK ]/bin/java must point on java executable) JAVA_HOME environment variable If none of the above varaiables are present, Jeka will run upon the java executable accessible from the PATH environment. Change the Repository Jeka uses to Fetch Dependencies \u00b6 By default, Jeka fetch dependencies from maven central (https://repo.maven.apache.org/maven2). Another default repository can be selected by setting the jeka.repos.download.url option. It has been recommended to store this value in your [USER DIR]/.jeka/options.properties file to be reused across projects. For more details, please see JkRepoFromOptions javadoc.","title":"Cheat Sheet"},{"location":"cheat-sheet/#useful-commands","text":"Jeka has predefined methods that comes either from JkClass or built-in plugins. jeka : Displays on console methods and options invokable from command line, along with plugins available in the classpath. jeka [kbean-name]#help : Displays on console methods and options invokable for the specified plugin (e.g. jeka scaffold#help ). jeka intellij#iml : Generates iml file for Intellij. It is generated accordingly the dependencies that is declared for Jeka project. jeka intellij#iml -JKC= : If the jeka intellij#iml fails due to the non-compile def classes, -JKC= will avoid def compilation phase. jeka eclipse#files : Same purpose as above to generate metadata files for Eclipse. jeka scaffold#run : Generates files for creating a basic Jeka project from scratch. jeka scaffold#wrapper : Generates wrapper files (jekaw/jekaw.bat and bootstrap jar). jeka scaffold#run java# : Generates files for creating a Jeka a project to build a JVM language project.","title":"Useful commands"},{"location":"cheat-sheet/#useful-standard-options","text":"You can add the below options to the command line. -kb=[KBeanName] : By default, Jeka instantiates the first KBean that is found under def directory to execute methods. It can be forced to instantiate a specific class by passing its long or short name. If the class is already in classpath, then no def compilation occurs. Simply, -JKC= is equivalent to -JKC=JkClass which is the base class bundled in Jeka . -lri : Displays runtime info which will be displayed meaningfully on console about current Jeka version, Java version, base directory, download repository, classpath, ... -lsu : Shows logs about Jeka setup (compilation of def classes, plugin loading, ...). This information is not logged by default. -ls=BRACE : Alters console output by delimiting tasks with braces and mentioning the processing time for each task. -ls=DEBUG : Alters console output by showing the class name and line number where the log has been emitted. -lv : Alters console output by displaying trace logs (emitted by JkLog#trace ). -cw : Clean .work directory, forcing compilation of def classes, even if it is marked as up-to-date.","title":"Useful standard options"},{"location":"cheat-sheet/#change-the-jdk-that-runs-jeka","text":"To determine the JDK to run upon, Jeka looks in priority order at : JEKA_JDK environment variable ([ JEKA_JDK ]/bin/java must point on java executable) JAVA_HOME environment variable If none of the above varaiables are present, Jeka will run upon the java executable accessible from the PATH environment.","title":"Change the JDK that Runs Jeka"},{"location":"cheat-sheet/#change-the-repository-jeka-uses-to-fetch-dependencies","text":"By default, Jeka fetch dependencies from maven central (https://repo.maven.apache.org/maven2). Another default repository can be selected by setting the jeka.repos.download.url option. It has been recommended to store this value in your [USER DIR]/.jeka/options.properties file to be reused across projects. For more details, please see JkRepoFromOptions javadoc.","title":"Change the Repository Jeka uses to Fetch Dependencies"},{"location":"examples/","text":"You can find some examples in below to learn more about Jeka : Samples are used for testing Jeka Working examples are more complex use case demos","title":"Examples"},{"location":"faq/","text":"General \u00b6 Can def classes be hosted in separate project than the code to build ? \u00b6 Yes. If you prefer that your Jeka code lies in a distinct project, create a Jeka project in a sibling folder and mention where is located the project to build. Path projectPath = this . baseDir (). resolve ( \"../myProject\" ); project . setBaseDir ( projectPath ); ... My JkClass does not compile, so I can't invoke any Jeka method as 'scaffold#run'. What can I do ? \u00b6 Use -dci option in command line. How to migrate from Maven ? \u00b6 Jeka helps to translate all dependencies declared in a Maven project into equivalent Java code. Assuming Maven is already installed and there is a pom.xml file at the root of the project, execute jeka maven#migrationCode to display Java code to copy-paste in a build class. Compilation \u00b6 How can I choose the JDK used to compile ? \u00b6 Jeka uses the JDK it is running on to compile production or test code. If code must be compiled on a another JDK version, you can specify JDK path for different version. Just mention it as option, for example in your [JEKA HOME]/options.properties file. jeka.jdk.9=/software/jdk9 This way, if one of your project source code is declared to be in a specific Java version, the relevant JDK version will be picked up automatically. How can I use Eclipse compiler in Jeka ? \u00b6 Jeka can use any JSR199 Java compiler to compile your Java code. Just set the compiler instance you need as : import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler ; @JkInjectClasspath ( \"org.eclipse.jdt.core.compiler:ecj:4.6.1\" ) public class Build extends JkBean { ... project . getConstruction () . getCompilation () . getCompiler () . setCompilerTool ( new EclipseCompiler ()); } How can I generate Eclipse/Intellij without using ProjectJkBean ? \u00b6 Just make your KBean class implements implements JkJavaIdeSupport`.","title":"FAQ"},{"location":"faq/#general","text":"","title":"General"},{"location":"faq/#can-def-classes-be-hosted-in-separate-project-than-the-code-to-build","text":"Yes. If you prefer that your Jeka code lies in a distinct project, create a Jeka project in a sibling folder and mention where is located the project to build. Path projectPath = this . baseDir (). resolve ( \"../myProject\" ); project . setBaseDir ( projectPath ); ...","title":"Can def classes be hosted in separate project than the code to build ?"},{"location":"faq/#my-jkclass-does-not-compile-so-i-cant-invoke-any-jeka-method-as-scaffoldrun-what-can-i-do","text":"Use -dci option in command line.","title":"My JkClass does not compile, so I can't invoke any Jeka method as 'scaffold#run'. What can I do ?"},{"location":"faq/#how-to-migrate-from-maven","text":"Jeka helps to translate all dependencies declared in a Maven project into equivalent Java code. Assuming Maven is already installed and there is a pom.xml file at the root of the project, execute jeka maven#migrationCode to display Java code to copy-paste in a build class.","title":"How to migrate from Maven ?"},{"location":"faq/#compilation","text":"","title":"Compilation"},{"location":"faq/#how-can-i-choose-the-jdk-used-to-compile","text":"Jeka uses the JDK it is running on to compile production or test code. If code must be compiled on a another JDK version, you can specify JDK path for different version. Just mention it as option, for example in your [JEKA HOME]/options.properties file. jeka.jdk.9=/software/jdk9 This way, if one of your project source code is declared to be in a specific Java version, the relevant JDK version will be picked up automatically.","title":"How can I choose the JDK used to compile ?"},{"location":"faq/#how-can-i-use-eclipse-compiler-in-jeka","text":"Jeka can use any JSR199 Java compiler to compile your Java code. Just set the compiler instance you need as : import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler ; @JkInjectClasspath ( \"org.eclipse.jdt.core.compiler:ecj:4.6.1\" ) public class Build extends JkBean { ... project . getConstruction () . getCompilation () . getCompiler () . setCompilerTool ( new EclipseCompiler ()); }","title":"How can I use Eclipse compiler in Jeka ?"},{"location":"faq/#how-can-i-generate-eclipseintellij-without-using-projectjkbean","text":"Just make your KBean class implements implements JkJavaIdeSupport`.","title":"How can I generate Eclipse/Intellij without using ProjectJkBean ?"},{"location":"reference-guide/build-library-3rd-party-tool-integration/","text":"The dev.jeka.core.api.tooling package provides integration with tools developers generally deal with. Eclipse \u00b6 JkEclipseClasspathGenerator and JkEclipseProjectGenerator provides method to generate a proper .classpath and .project file respectively. JkEclipseClasspathApplier reads information from a .classpath file. Intellij \u00b6 JkIntellijImlGenerator generates proper .iml files. Git \u00b6 JkGitWrapper wraps common Git commands in a lean API. Maven \u00b6 JkMvn wraps Maven command line in a lean API JkPom reads POM/BOM to extract information like : declared dependencies, dependency management, repos, properties, version and artifactId.","title":"3rd Party Tool Integration"},{"location":"reference-guide/build-library-3rd-party-tool-integration/#eclipse","text":"JkEclipseClasspathGenerator and JkEclipseProjectGenerator provides method to generate a proper .classpath and .project file respectively. JkEclipseClasspathApplier reads information from a .classpath file.","title":"Eclipse"},{"location":"reference-guide/build-library-3rd-party-tool-integration/#intellij","text":"JkIntellijImlGenerator generates proper .iml files.","title":"Intellij"},{"location":"reference-guide/build-library-3rd-party-tool-integration/#git","text":"JkGitWrapper wraps common Git commands in a lean API.","title":"Git"},{"location":"reference-guide/build-library-3rd-party-tool-integration/#maven","text":"JkMvn wraps Maven command line in a lean API JkPom reads POM/BOM to extract information like : declared dependencies, dependency management, repos, properties, version and artifactId.","title":"Maven"},{"location":"reference-guide/build-library-dependency-management/","text":"For Jeka, a dependency is something that can be resolved to a set of files by a JkDependencyResolver . Generally a dependency resolves to 1 file (or folder) but it can be 0 or many. Compared to mainstream build tools, Jeka offers a simpler and more flexible model to deals with multiple dependency configurations required for building a project. See project dependencies Types of Dependency \u00b6 A dependency is always an instance of JkDependency . Jeka distinguishes mainly 3 types of dependency : Arbitrary files located on the file system (represented by JkFileSystemDependency class). These files are assumed to be present on the file system when the build is running. Files produced by a computation (represented by JkComputedDependency class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project. Coordinate pointing to a remote artifact (represented by JkCoordinateDependency ) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and resolve transitively any artifact located in a repository as you would do with Maven, Ivy or Gradle. For the last, Jeka is using Ivy 2.5.0 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code. Coordinate dependency \u00b6 This type of dependency is represented by JkCoordinateDependency class. It stands for a Maven/Ivy dependency expressed with coordinates (e.g. _group:module:version). This is for declaring a dependency on module hosted in Maven or Ivy repository. Basically you instantiate a JkCoordinateDependency from it's group, name and version. JkDependencySet . of () . and ( JkPopularModule . GUAVA , \"18.0\" ) . and ( \"com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[\" ) . and ( \"mygroup:mymodule:myclassifier:0.2-SNAPSHOT\" ); Many string formats are accepted to specify a module coordinate : group : name group : name : version group : name : classifier : version group : name : classifier : extension : version Classifier can be either : an empty string to specify the default classifier a simple string as ' linux ' to specify a retrieve a single classifier variant Note By default, dependencies specifying a classifier or an extension are not considered as transitive. Tough, transitivity can be explicitly configured. Version can be either : a static version number, as 1.0.2 a snapshot version, as 1.0.2-SNAPSHOT a version range, as [2.0.8, 2.1.0[ Examples : com.sun.jersey:jersey-server : specify artifact without version com.sun.jersey:jersey-server:1.19.4 : specify artifact with version org.lwjgl:lwjgl:natives_linux:3.1.0 : specify artifact having natives_linux classifier and 3.1.0 version org.springframework.boot:spring-boot-dependencies::pom:2.5.6 specify artifact having .pom extension (to retrieve a BOM) Note A version ending by -SNAPSHOT has a special meaning : Jeka will consider it \"changing\" . This means that it won't cache it locally and will download the latest version from repository. As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned here . Dependency files are downloaded in [USER HOME] /.jeka/cache/repo Additionally, it's possible to define the transitivity of the dependency using : JkModuleDependency.of(\"group:name:sources:zip:version\").withTransitivity(JkTransitivity.NONE); By default, Jeka uses the most relevant transitivity according the declaration context, so users don't need to specify it unless they want a specific one. See later for more details about transitivity . File System Dependencies \u00b6 This type of dependency is represented by JkFileSystemDependency class. Just mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails. JkDependencySet . of (). andFiles ( \"libs/my.jar\" , \"libs/my.testingtool.jar\" ); Computed Dependencies \u00b6 This type of dependency is represented by JkComputedDependency class. It is typically used for multi-modules or multi-techno projects. The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails. This mechanism is quite simple yet powerful as it addresses following use cases : Dependencies on files produced by an artifact producer ( JkArtifactProducer ). A JkProject is an artifact producer. Dependencies on files produced by external build tool (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...). ... In other words, files produced by any means. The generic way is to construct this kind of dependency using a java.lang.Runnable . The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka . Path mavenProject = Paths . get ( \"../a-maven-project\" ); JkProcess mavenBuild = JkProcess . of ( \"mvn\" , \"clean\" , \"install\" ) . withWorkingDir ( mavenProject ); Path mavenProjectJar = mavenProject . resolve ( \"target/maven-project.jar\" ); JkJavaProject externalProject = JkJavaProject . ofSimple ( Paths . get ( \"../a-jeka-project\" )); JkDependencySet deps = JkDependencySet . of () . and ( JkComputedDependency . of ( mavenBuild , mavenProjectJar )) . and ( externalProject ); Dependency Set \u00b6 A dependency set ( JkDependencySet ) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of JkDependency . See here dependencySet also defines : A version provider to define which version of a module we should use in case it is not explicitly mentioned. A set of transitive dependency exclusion rules. It is designed as an immutable object where we can apply set theory operations for adding, removing or merging with other dependencies and dependencySet . Example JkDependencySet deps = JkDependencySet . of () . and ( \"com.google.guava\" ) . and ( \"org.slf4j:slf4j-simple\" ) . and ( \"com.orientechnologies:orientdb-client:2.0.8\" ) . andFile ( \"../libs.myjar\" ) . withVersionProvider ( myVersionProvider ); Note Module version and scopes can be omitted when declaring dependencies. Versions can be provided by a JkVersionProvider . Instances of JkDependencySet can be combined together in order to construct large dependencySet from smaller ones. Transitivity \u00b6 For each dependency, mainstream build tools use a single concept ( scope or configuration ) to determine both : which part of the build needs the dependency which transitive dependencies to fetch along the dependency with which transitivity the dependency must be published This confusion leads in dependency management systems that are bloated, difficult to reason about and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a fewer but with limitations and not-so-clear transitivity/publish rules. In the opposite, Jeka distinguishes clearly the three purposes : Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be defined relatively to another using set theory operations. For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency. For publishing, we can optionally re-define a specific dependencySet , exposing exactly what we want. Jeka defines by default, 3 levels of transitivity : NONE : Not transitive COMPILE : Also fetch transitive dependencies declared with scope 'compile' in the dependency published pom. RUNTIME : Also fetch transitive dependencies declared with any scope in the dependency published pom. Notes On Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'. For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'. The below example shows a JkJavaProject declaration using explicit transitivity. JkJavaProject . of (). simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:23.0\" , JkTransitivity . NONE ) . and ( \"javax.servlet:javax.servlet-api:4.0.1\" )) . configureRuntimeDeps ( deps -> deps . and ( \"org.postgresql:postgresql:42.2.19\" ) . withTransitivity ( \"com.google.guava:guava\" , JkTransitivity . RUNTIME ) . minus ( \"javax.servlet:javax.servlet-api\" )) . configureTestDeps ( deps -> deps . and ( Hint . first (), \"org.mockito:mockito-core:2.10.0\" ) ) It results in : Declared Compile Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:NONE javax.servlet:javax.servlet-api:4.0.1 Declared Runtime Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 Declared Test Dependencies : 4 elements. org.mockito:mockito-core:2.10.0 com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 javax.servlet:javax.servlet-api:4.0.1 Dependencies without any transitivity specified on, will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies. The API allows to redefine the transitivity declared in a upper dependency set. Note that transitivity can only apply to JkModuleDependency (like com.google.guava:guava:23.0 ) and JkLocalProjectDependency . Resolve Dependencies \u00b6 The JkDependencyResolver class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning JkResolveResult from a JkdependencySet . JkDependencySet deps = JkDependencySet . of () . and ( \"org.apache.httpcomponents:httpclient:4.5.3\" ) . andFile ( \"libs/my.jar\" ); // Here, module dependencies are fetched from Maven central repo JkDependencyResolver resolver = JkDependencyResolver . of ( JkRepo . ofMavenCentral ()); JkResolveResult result = resolver (). resolve ( deps ); From the result you can : Navigate in the resolved dependency tree as : JkDependencyNode slfjApiNodeDep = result . getDependencyTree () . getFirst ( JkModuleId . of ( \"org.slf4j:slf4j-api\" )); System . out . println ( slfjApiNode . getModuleInfo (). getResolvedVersion ()); Get the direct list of artifact files JkPathSequence sequence = result . getFiles (); sequence . forEach ( System . out :: println ); // print each files part of the result Publication \u00b6 Jeka is able to publish on both Maven and Ivy repository. This includes repositories as Sonatype Nexus . Maven and Ivy have different publication model, so Jeka proposes specific APIs according you want to publish on a Maven or Ivy repository. Publish to a Maven repository \u00b6 Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according provided elements. Find an example here Notice that Jeka allows to : Publish more than one artifact. Produce & publish checksum files for each published artifact. Mention to use unique snapshot ( What is it ? ). Feed generated pom with data necessary to publish on central repository . Sign published artifact with PGP Publish to multiple repository by creating the publisher using a JkRepoSet instead of a JkRepo . To sign with PGP, no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts. Publish to a Ivy repository \u00b6 Publishing on Ivy repo is pretty similar than on Maven though there is specific options to Ivy. See also here Common Classes \u00b6 JkRepo and JkRepoSet represent both download and upload repositories. JkRepoFromProperties provides configured repositories according global or project scopes properties . JkDependencySet represents a set of dependencies. JkDependencyResolver resolve dependencies to classpath and resolution result that allow resolution exploration. JkModuleFileProxy provides an smart way to get a file from its coordinates.","title":"Delependency Management"},{"location":"reference-guide/build-library-dependency-management/#types-of-dependency","text":"A dependency is always an instance of JkDependency . Jeka distinguishes mainly 3 types of dependency : Arbitrary files located on the file system (represented by JkFileSystemDependency class). These files are assumed to be present on the file system when the build is running. Files produced by a computation (represented by JkComputedDependency class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project. Coordinate pointing to a remote artifact (represented by JkCoordinateDependency ) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and resolve transitively any artifact located in a repository as you would do with Maven, Ivy or Gradle. For the last, Jeka is using Ivy 2.5.0 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code.","title":"Types of Dependency"},{"location":"reference-guide/build-library-dependency-management/#coordinate-dependency","text":"This type of dependency is represented by JkCoordinateDependency class. It stands for a Maven/Ivy dependency expressed with coordinates (e.g. _group:module:version). This is for declaring a dependency on module hosted in Maven or Ivy repository. Basically you instantiate a JkCoordinateDependency from it's group, name and version. JkDependencySet . of () . and ( JkPopularModule . GUAVA , \"18.0\" ) . and ( \"com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[\" ) . and ( \"mygroup:mymodule:myclassifier:0.2-SNAPSHOT\" ); Many string formats are accepted to specify a module coordinate : group : name group : name : version group : name : classifier : version group : name : classifier : extension : version Classifier can be either : an empty string to specify the default classifier a simple string as ' linux ' to specify a retrieve a single classifier variant Note By default, dependencies specifying a classifier or an extension are not considered as transitive. Tough, transitivity can be explicitly configured. Version can be either : a static version number, as 1.0.2 a snapshot version, as 1.0.2-SNAPSHOT a version range, as [2.0.8, 2.1.0[ Examples : com.sun.jersey:jersey-server : specify artifact without version com.sun.jersey:jersey-server:1.19.4 : specify artifact with version org.lwjgl:lwjgl:natives_linux:3.1.0 : specify artifact having natives_linux classifier and 3.1.0 version org.springframework.boot:spring-boot-dependencies::pom:2.5.6 specify artifact having .pom extension (to retrieve a BOM) Note A version ending by -SNAPSHOT has a special meaning : Jeka will consider it \"changing\" . This means that it won't cache it locally and will download the latest version from repository. As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned here . Dependency files are downloaded in [USER HOME] /.jeka/cache/repo Additionally, it's possible to define the transitivity of the dependency using : JkModuleDependency.of(\"group:name:sources:zip:version\").withTransitivity(JkTransitivity.NONE); By default, Jeka uses the most relevant transitivity according the declaration context, so users don't need to specify it unless they want a specific one. See later for more details about transitivity .","title":"Coordinate dependency"},{"location":"reference-guide/build-library-dependency-management/#file-system-dependencies","text":"This type of dependency is represented by JkFileSystemDependency class. Just mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails. JkDependencySet . of (). andFiles ( \"libs/my.jar\" , \"libs/my.testingtool.jar\" );","title":"File System Dependencies"},{"location":"reference-guide/build-library-dependency-management/#computed-dependencies","text":"This type of dependency is represented by JkComputedDependency class. It is typically used for multi-modules or multi-techno projects. The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails. This mechanism is quite simple yet powerful as it addresses following use cases : Dependencies on files produced by an artifact producer ( JkArtifactProducer ). A JkProject is an artifact producer. Dependencies on files produced by external build tool (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...). ... In other words, files produced by any means. The generic way is to construct this kind of dependency using a java.lang.Runnable . The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka . Path mavenProject = Paths . get ( \"../a-maven-project\" ); JkProcess mavenBuild = JkProcess . of ( \"mvn\" , \"clean\" , \"install\" ) . withWorkingDir ( mavenProject ); Path mavenProjectJar = mavenProject . resolve ( \"target/maven-project.jar\" ); JkJavaProject externalProject = JkJavaProject . ofSimple ( Paths . get ( \"../a-jeka-project\" )); JkDependencySet deps = JkDependencySet . of () . and ( JkComputedDependency . of ( mavenBuild , mavenProjectJar )) . and ( externalProject );","title":"Computed Dependencies"},{"location":"reference-guide/build-library-dependency-management/#dependency-set","text":"A dependency set ( JkDependencySet ) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of JkDependency . See here dependencySet also defines : A version provider to define which version of a module we should use in case it is not explicitly mentioned. A set of transitive dependency exclusion rules. It is designed as an immutable object where we can apply set theory operations for adding, removing or merging with other dependencies and dependencySet . Example JkDependencySet deps = JkDependencySet . of () . and ( \"com.google.guava\" ) . and ( \"org.slf4j:slf4j-simple\" ) . and ( \"com.orientechnologies:orientdb-client:2.0.8\" ) . andFile ( \"../libs.myjar\" ) . withVersionProvider ( myVersionProvider ); Note Module version and scopes can be omitted when declaring dependencies. Versions can be provided by a JkVersionProvider . Instances of JkDependencySet can be combined together in order to construct large dependencySet from smaller ones.","title":"Dependency Set"},{"location":"reference-guide/build-library-dependency-management/#transitivity","text":"For each dependency, mainstream build tools use a single concept ( scope or configuration ) to determine both : which part of the build needs the dependency which transitive dependencies to fetch along the dependency with which transitivity the dependency must be published This confusion leads in dependency management systems that are bloated, difficult to reason about and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a fewer but with limitations and not-so-clear transitivity/publish rules. In the opposite, Jeka distinguishes clearly the three purposes : Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be defined relatively to another using set theory operations. For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency. For publishing, we can optionally re-define a specific dependencySet , exposing exactly what we want. Jeka defines by default, 3 levels of transitivity : NONE : Not transitive COMPILE : Also fetch transitive dependencies declared with scope 'compile' in the dependency published pom. RUNTIME : Also fetch transitive dependencies declared with any scope in the dependency published pom. Notes On Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'. For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'. The below example shows a JkJavaProject declaration using explicit transitivity. JkJavaProject . of (). simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:23.0\" , JkTransitivity . NONE ) . and ( \"javax.servlet:javax.servlet-api:4.0.1\" )) . configureRuntimeDeps ( deps -> deps . and ( \"org.postgresql:postgresql:42.2.19\" ) . withTransitivity ( \"com.google.guava:guava\" , JkTransitivity . RUNTIME ) . minus ( \"javax.servlet:javax.servlet-api\" )) . configureTestDeps ( deps -> deps . and ( Hint . first (), \"org.mockito:mockito-core:2.10.0\" ) ) It results in : Declared Compile Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:NONE javax.servlet:javax.servlet-api:4.0.1 Declared Runtime Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 Declared Test Dependencies : 4 elements. org.mockito:mockito-core:2.10.0 com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 javax.servlet:javax.servlet-api:4.0.1 Dependencies without any transitivity specified on, will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies. The API allows to redefine the transitivity declared in a upper dependency set. Note that transitivity can only apply to JkModuleDependency (like com.google.guava:guava:23.0 ) and JkLocalProjectDependency .","title":"Transitivity"},{"location":"reference-guide/build-library-dependency-management/#resolve-dependencies","text":"The JkDependencyResolver class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning JkResolveResult from a JkdependencySet . JkDependencySet deps = JkDependencySet . of () . and ( \"org.apache.httpcomponents:httpclient:4.5.3\" ) . andFile ( \"libs/my.jar\" ); // Here, module dependencies are fetched from Maven central repo JkDependencyResolver resolver = JkDependencyResolver . of ( JkRepo . ofMavenCentral ()); JkResolveResult result = resolver (). resolve ( deps ); From the result you can : Navigate in the resolved dependency tree as : JkDependencyNode slfjApiNodeDep = result . getDependencyTree () . getFirst ( JkModuleId . of ( \"org.slf4j:slf4j-api\" )); System . out . println ( slfjApiNode . getModuleInfo (). getResolvedVersion ()); Get the direct list of artifact files JkPathSequence sequence = result . getFiles (); sequence . forEach ( System . out :: println ); // print each files part of the result","title":"Resolve Dependencies"},{"location":"reference-guide/build-library-dependency-management/#publication","text":"Jeka is able to publish on both Maven and Ivy repository. This includes repositories as Sonatype Nexus . Maven and Ivy have different publication model, so Jeka proposes specific APIs according you want to publish on a Maven or Ivy repository.","title":"Publication"},{"location":"reference-guide/build-library-dependency-management/#publish-to-a-maven-repository","text":"Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according provided elements. Find an example here Notice that Jeka allows to : Publish more than one artifact. Produce & publish checksum files for each published artifact. Mention to use unique snapshot ( What is it ? ). Feed generated pom with data necessary to publish on central repository . Sign published artifact with PGP Publish to multiple repository by creating the publisher using a JkRepoSet instead of a JkRepo . To sign with PGP, no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts.","title":"Publish to a Maven repository"},{"location":"reference-guide/build-library-dependency-management/#publish-to-a-ivy-repository","text":"Publishing on Ivy repo is pretty similar than on Maven though there is specific options to Ivy. See also here","title":"Publish to a Ivy repository"},{"location":"reference-guide/build-library-dependency-management/#common-classes","text":"JkRepo and JkRepoSet represent both download and upload repositories. JkRepoFromProperties provides configured repositories according global or project scopes properties . JkDependencySet represents a set of dependencies. JkDependencyResolver resolve dependencies to classpath and resolution result that allow resolution exploration. JkModuleFileProxy provides an smart way to get a file from its coordinates.","title":"Common Classes"},{"location":"reference-guide/build-library-files/","text":"Files \u00b6 File manipulation is a central part for building software. Jeka embraces JDK7 java.nio.file API by adding some concepts around, to provide a powerful fluent style API performing recurrent tasks with minimal effort. The following classes lie in dev.jeka.core.api.file package: JkPathFile A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods. JkPathSequence An Immutable sequence of java.nio.file.Path providing methods for filtering or appending. JkPathMatcher An immutable java.nio.file.PathMatcher based on java.nio.file glob pattern or regerxp. Used by JkPathTree to filter in/out files according name patterns. JkPathTree An Immutable root folder along a PathMatcher providing operations to copy, navigate, zip or iterate. This is a central class in Jeka API. JkZipTree Same as JkPathTree but using a zip file instead of a directory. It allows to manipulate a zip file as a regular folder. JkPathTreeSet An Immutable set of JkPathTree . Helpful to define set of sources/resources and create jar/zip files. JkResourceProcessor A mutable processor for copying a set of files, preserving the structure and replacing some text by other text. Typically, used for replacing token as ${server.ip} by an actual value. Examples // creates a file and writes the content of the specified url. JkPathFile . of ( \"config/my-config.xml\" ). createIfNotExist (). replaceContentBy ( \"http://myserver/conf/central.xml\" ); // copies all non java source files to another directory preserving structure JkPathTree . of ( \"src\" ). andMatching ( false , \"**/*.java\" ). copyTo ( \"build/classes\" ); // One liner to zip an entire directory JkPathTree . of ( \"build/classes\" ). zipTo ( Paths . get ( \"mylib.jar\" ));","title":"File Management"},{"location":"reference-guide/build-library-files/#files","text":"File manipulation is a central part for building software. Jeka embraces JDK7 java.nio.file API by adding some concepts around, to provide a powerful fluent style API performing recurrent tasks with minimal effort. The following classes lie in dev.jeka.core.api.file package: JkPathFile A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods. JkPathSequence An Immutable sequence of java.nio.file.Path providing methods for filtering or appending. JkPathMatcher An immutable java.nio.file.PathMatcher based on java.nio.file glob pattern or regerxp. Used by JkPathTree to filter in/out files according name patterns. JkPathTree An Immutable root folder along a PathMatcher providing operations to copy, navigate, zip or iterate. This is a central class in Jeka API. JkZipTree Same as JkPathTree but using a zip file instead of a directory. It allows to manipulate a zip file as a regular folder. JkPathTreeSet An Immutable set of JkPathTree . Helpful to define set of sources/resources and create jar/zip files. JkResourceProcessor A mutable processor for copying a set of files, preserving the structure and replacing some text by other text. Typically, used for replacing token as ${server.ip} by an actual value. Examples // creates a file and writes the content of the specified url. JkPathFile . of ( \"config/my-config.xml\" ). createIfNotExist (). replaceContentBy ( \"http://myserver/conf/central.xml\" ); // copies all non java source files to another directory preserving structure JkPathTree . of ( \"src\" ). andMatching ( false , \"**/*.java\" ). copyTo ( \"build/classes\" ); // One liner to zip an entire directory JkPathTree . of ( \"build/classes\" ). zipTo ( Paths . get ( \"mylib.jar\" ));","title":"Files"},{"location":"reference-guide/build-library-intro/","text":"Jeka contains a library for all regular things you need to build/test/publish projects.. The library does not depend on the execution engine and has zero dependency. API Style \u00b6 Jeka tries to stick with a consistent API design style. All Jeka public classes/interfaces start with Jk . The reason is for easing distinction, in IDE, between classes supposed be used in production or test and the ones used for building. It also helps to explore Jeka API. As a rule of thumb Jeka favors immutable objects for shallow structures and parent-chaining trees for deeper ones. Both provide a fluent interface when possible. In deep structure, final fields are declared public and have no getter counterpart. All objects are instantiated using static factory methods. Every factory method names start with of . All accessor method names (methods returning a result without requiring IO, meaning computation only) starts with get . To create a subtly different object from another immutable one, Jeka provides : Methods starting with with when a property is to be replaced by another. Methods starting with and when a collection property is to be replaced by the same one plus an extra element. Methods starting with minus when a collection property is to be replaced by the same one minus a specified element. To modify a mutable object, Jeka provides : Methods starting with set to replace a single property value by another. Methods starting with add to add a value to a collection property. Those methods return the object itself for chaining. Domains Covered by the API \u00b6 The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API relies on other lower level ones provided by Jeka . In a glance these are the domains covered by the Jeka APIs : Files : File trees, filters, zip, path sequence System : Launching external process, Logging, Meta-info Cryptography : PGP signer Dependency management : Dependency management, publishing on repositories Java : Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching Testing : Launching tests and get reports Project : Project structure to build Tooling : Eclipse integration, intellij integration, Maven interaction, Git Support : Set of utility class with static methods to handle low-level concerns","title":"Intro"},{"location":"reference-guide/build-library-intro/#api-style","text":"Jeka tries to stick with a consistent API design style. All Jeka public classes/interfaces start with Jk . The reason is for easing distinction, in IDE, between classes supposed be used in production or test and the ones used for building. It also helps to explore Jeka API. As a rule of thumb Jeka favors immutable objects for shallow structures and parent-chaining trees for deeper ones. Both provide a fluent interface when possible. In deep structure, final fields are declared public and have no getter counterpart. All objects are instantiated using static factory methods. Every factory method names start with of . All accessor method names (methods returning a result without requiring IO, meaning computation only) starts with get . To create a subtly different object from another immutable one, Jeka provides : Methods starting with with when a property is to be replaced by another. Methods starting with and when a collection property is to be replaced by the same one plus an extra element. Methods starting with minus when a collection property is to be replaced by the same one minus a specified element. To modify a mutable object, Jeka provides : Methods starting with set to replace a single property value by another. Methods starting with add to add a value to a collection property. Those methods return the object itself for chaining.","title":"API Style"},{"location":"reference-guide/build-library-intro/#domains-covered-by-the-api","text":"The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API relies on other lower level ones provided by Jeka . In a glance these are the domains covered by the Jeka APIs : Files : File trees, filters, zip, path sequence System : Launching external process, Logging, Meta-info Cryptography : PGP signer Dependency management : Dependency management, publishing on repositories Java : Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching Testing : Launching tests and get reports Project : Project structure to build Tooling : Eclipse integration, intellij integration, Maven interaction, Git Support : Set of utility class with static methods to handle low-level concerns","title":"Domains Covered by the API"},{"location":"reference-guide/build-library-project-build/","text":"Jeka features high-level and low-level classes to deal with Java builds and JVM concepts. Package dev.jeka.core.api.java \u00b6 Base classes are used as foundation for implementing Jeka high-level build API but they can be used directly in a low level build description. These classes belong to dev.jeka.core.api.java package . JkClassLoader and JkUrlClassloader Wrap a java.lang.ClassLoader adding convenient methods and classpath scanning capability. JkJarPacker A simple utility tyo create Jar or fat Jar file from compiled classes. JkJavaCompiler Wraps either a Java Compiler tool, or a javac process. JkJavadocProcessor A Java source processor producing standard Javadoc JkJavaProcess A utility to launch Java process (from class dirs or jars) JkManifest Stands for the manifest file to include in jar files. Package dev.jeka.core.api.j2e \u00b6 JkJ2eWarArchiver : Provides methods to generates war files, including dependency jars. JkJ2eWarProjectAdapter : Helps to adapt an existing JkProject to make it generate war artefacts_. Package dev.jeka.core.api.kotlin \u00b6 JkKotlinCompiler : Provides mean to get a suitable compiler according a given Kotlin version. This class also provides methods to compile Kotlin sources in a fluent way. JkKotlinModules : Holds constants of common Kotlin library coordinates. Package dev.jeka.core.api.testing \u00b6 Jeka features a simple yet powerful API to launch tests. It relies entirely on JUnit5. This means that any test framework supported by Junit5 platform. Jeka testing API mostly hides Junit Platform . For most of the cases, you won't need to code against Junit-Platform API to launch tests with Jeka. Nevertheless, Jeka allows users to code against Junit-Platform for fine-tuning. The API classes all belongs to dev.jeka.core.api.testing package . JkTestProcessor \u00b6 This is the entry point to launch tests. Tests are executed using the current classloader classpath + extra class path mentioned in #launch method arguments. We can access to JkEngineBehavior by JkTestProcessor#getEngineBehavior() . From there we can Select output dir of the test report Change how test progress is displayed Modify how JUnitPlatform will behave by accessing directly to the JunitPlatform API JkTestSelection \u00b6 This is the object passed as argument of JkTestProcessor#launch to determine which test to launch. It can be set using file or tag filter. It is also possible to code against JunitPlatform API (example here ). JkTestResult \u00b6 The result of a test launch. Ir provides count for tests found, failure, skip, success ... Package dev.jeka.core.api.project \u00b6 This is the Jeka high-level API to build Java/JVM projects. API classes belong to dev.jeka.core.api.project package . It introduces the concept of JkProject from where it performs compilation, testing, resources processing, packaging, publication and more. JkProject is the root of a deep structure embracing the parent-chaining pattern for readability. The API contains a lot of extension points to add specific behaviors. Project Structure \u00b6 JkProject structure project +- baseDir +- outputDir +- artifactProducer (define artifacts procuded by the build) +- duplicateDependencyConflictStrategy +- jvmTargetVersion +- sourceEncoding +- javaCompiler +- dependencyResolver +- prodCompilation (produce individual binary files from production sources. This includes resource processing, code generation, processing on .class files, ...) | +- layout (where are located source and resource files) | +- source generators (plugin mechanism for generating source files) | +- dependencies (stands for compile dependencies) | +- preCompileActions (including resources processing) | +- compileActions (including java sources compilation. Compilation for other languages can be added here) | +- postCompileActions | +- methods : resolveDependencies(), run() +- testing | +- testCompilation (same as above 'prodcCompilation' but for test sources) | | +- layout | | +- dependencies (stands for test dependencies) | | + ... | +- breakOnFailure (true/false) | +- skipped (true/false) | +- testProcessor | | +- forkedProcess (configured the forked process who will run tests) | | +- preActions | | +- postActions | | +- engineBehavior | | | +- testReportDir | | | +- progressDisplayer | | | +- launcherConfiguration (based on junit5 platform API) | | +- testSelection | | | +- includePatterns | | | +- includeTags | +- method : run() +- packaging (produces javadoc and source jar and bin jars) | +- javadocConfiguration | +- runtimeDependencies | +- manifest | +- fatJar (customize produced fat/uber jar if any) | +- methods : createJavadocJar(), createSourceJar(), createBinJar(), createFatJar(), resolveRuntimeDependencies() +- publication (define information about module and artifacts to be published) | +- moduleId (group:name) | +- version | +- maven (maven specific information to be published in a Maven Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- mavenSpecificInfo | | +- method : publish() | +- ivy (Ivy specific information to be published in a Ivy Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- ivySpecifictInfo | | +- method : publish() | +- methods : publish(), getVersion(), getModuleId() + methods : getArtifacctPath(artifactName), toDependency(transitivity), getIdeSupport(), pack(), +- methods : getDependenciesAsXml(), includeLocalAndTextDependencies() For convenience, JkProject provides a facade in order to make common settings friendly, without navigating deep into the structure. From facade, you can setup dependencies, java version, project layout, test behavior, test selection and publication. JkProject . of (). flatFacade () . configureCompileDependencies ( deps -> deps . and ( \"com.google.guava:guava:21.0\" ) . and ( \"com.sun.jersey:jersey-server:1.19.4\" ) . and ( \"org.junit.jupiter:junit-jupiter-engine:5.6.0\" )) . configureRuntimeDependencies ( deps -> deps . minus ( \"org.junit.jupiter:junit-jupiter-engine\" ) . and ( \"com.github.djeang:vincer-dom:1.2.0\" )) . configureTestDependencies ( deps -> deps . and ( \"org.junit.vintage:junit-vintage-engine:5.6.0\" )) . addTestExcludeFilterSuffixedBy ( \"IT\" , false ) . setJavaVersion ( JkJavaVersion . V8 ) . setPublishedModuleId ( \"dev.jeka:sample-javaplugin\" ) . setPublishedVersion ( \"1.0-SNAPSHOT\" ); If facade is not sufficient for setting up the project build, you can use the main API. JkProject instances are highly configurable. Here is a pretty complete example inspired from the Jeka Build Class . Dependencies \u00b6 Project dependencies are managed differently than in Maven/Gradle. Instead of defining a single collection of dependencies, each bounded for a specific scope/configuration, Jeka projects define 3 distinct classpath : compile, runtime and test. Each classpath defines its own set of dependencies independently tough they are defined relatively to each other. Compile classpath : is defined using project.getCompilation().configureDependencies() . Runtime classpath : is defined from Compile Classpath . This base can be modified using project.packaging.configureDependencies() . Test classpath : is defined from a merge of Compile Classpath and Runtime Classpath . This base can be modified using project.getTesing().getCompilation().configureDependencies() Full Text Description \u00b6 An entire project dependency sets can be declared with full text description. For this, just pass a string argument to JkDependencySet#ofTextDescription describing the module dependencies. When using ProjectJkBean , the content of the file jeka/libs/dependencies.txt is automatically added to the project dependencies, tough it can be modified programmatically. Dependencies have to be declared with format group:module:[classifier]:[type]:[version] where classifier , type and version' are optional. See `JkCoordinate.of(String description) for details. To import bill-of-materials (aka BOMs) just declare a dependency as '*group:module::pom:version' Example == COMPILE == org.lwjgl:lwjgl-bom::pom:3.3.1 # Use lwjgl BOM so we don't need to specify lwjgl versions afterward org.lwjgl:lwjgl:natives-linux:: # specify the 'natives-linux' classifier for lwjgl org.projectlombok:lombok:1.16.16 == RUNTIME == org.postgresql:postgresql:42.5.0 - org.projectlombok:lombok # remove lombok from runtime dependencies == TEST == org.seleniumhq.selenium:selenium-chrome-driver:3.4.0 org.fluentlenium:fluentlenium-junit:3.2.0 @ org.apache.httpcomponents:httpclient # exclude http-client from fluentlenium-junit transitive dependencies org.fluentlenium:fluentlenium-assertj:3.2.0 @@ net.sourceforge.htmlunit:htmlunit # exclude htmlunit from all transitive dependencies == COMPILE == Defines dependencies that will constitute the compile classpath. == RUNTIME == Defines dependencies that will constitute the runtime classpath. The dependencies will be the ones declared in == COMPILE == section plus the ones declared in == RUNTIME == section. If dependencies declared in == compile == section should not be included for runtime classpath, it should be explicitly be removed using '-' symbol. == TEST == Defines dependencies that will constitute the test classpath. The dependencies will be the ones declared in == COMPILE == or == RUNTIME == sections (merge) plus the ones declared in == TEST == section. Tip If you are using Jeka plugin for Intellij, hit ctrl+<space> for displaying suggestions. Publication \u00b6 Projects can be published on a binary repositories (as Maven or Ivy repo) using project.getPubliication().publish() . When this method is invoked, all artifacts defined in the projects are published. Artifacts can be binary, sources, javadoc or any kind of file. When published on repository, a metadata file is generated mentioning moduleId, version and transitive dependencies. Transitive dependencies are inferred from compile and runtime dependencies declared for the project, tough it can be modified programmatically using respectively project.getPublication().getMaven().configureDependencies() and project.getPublication().getIvy().configureDependencies() .","title":"Project Build"},{"location":"reference-guide/build-library-project-build/#package-devjekacoreapijava","text":"Base classes are used as foundation for implementing Jeka high-level build API but they can be used directly in a low level build description. These classes belong to dev.jeka.core.api.java package . JkClassLoader and JkUrlClassloader Wrap a java.lang.ClassLoader adding convenient methods and classpath scanning capability. JkJarPacker A simple utility tyo create Jar or fat Jar file from compiled classes. JkJavaCompiler Wraps either a Java Compiler tool, or a javac process. JkJavadocProcessor A Java source processor producing standard Javadoc JkJavaProcess A utility to launch Java process (from class dirs or jars) JkManifest Stands for the manifest file to include in jar files.","title":"Package dev.jeka.core.api.java"},{"location":"reference-guide/build-library-project-build/#package-devjekacoreapij2e","text":"JkJ2eWarArchiver : Provides methods to generates war files, including dependency jars. JkJ2eWarProjectAdapter : Helps to adapt an existing JkProject to make it generate war artefacts_.","title":"Package dev.jeka.core.api.j2e"},{"location":"reference-guide/build-library-project-build/#package-devjekacoreapikotlin","text":"JkKotlinCompiler : Provides mean to get a suitable compiler according a given Kotlin version. This class also provides methods to compile Kotlin sources in a fluent way. JkKotlinModules : Holds constants of common Kotlin library coordinates.","title":"Package dev.jeka.core.api.kotlin"},{"location":"reference-guide/build-library-project-build/#package-devjekacoreapitesting","text":"Jeka features a simple yet powerful API to launch tests. It relies entirely on JUnit5. This means that any test framework supported by Junit5 platform. Jeka testing API mostly hides Junit Platform . For most of the cases, you won't need to code against Junit-Platform API to launch tests with Jeka. Nevertheless, Jeka allows users to code against Junit-Platform for fine-tuning. The API classes all belongs to dev.jeka.core.api.testing package .","title":"Package dev.jeka.core.api.testing"},{"location":"reference-guide/build-library-project-build/#jktestprocessor","text":"This is the entry point to launch tests. Tests are executed using the current classloader classpath + extra class path mentioned in #launch method arguments. We can access to JkEngineBehavior by JkTestProcessor#getEngineBehavior() . From there we can Select output dir of the test report Change how test progress is displayed Modify how JUnitPlatform will behave by accessing directly to the JunitPlatform API","title":"JkTestProcessor"},{"location":"reference-guide/build-library-project-build/#jktestselection","text":"This is the object passed as argument of JkTestProcessor#launch to determine which test to launch. It can be set using file or tag filter. It is also possible to code against JunitPlatform API (example here ).","title":"JkTestSelection"},{"location":"reference-guide/build-library-project-build/#jktestresult","text":"The result of a test launch. Ir provides count for tests found, failure, skip, success ...","title":"JkTestResult"},{"location":"reference-guide/build-library-project-build/#package-devjekacoreapiproject","text":"This is the Jeka high-level API to build Java/JVM projects. API classes belong to dev.jeka.core.api.project package . It introduces the concept of JkProject from where it performs compilation, testing, resources processing, packaging, publication and more. JkProject is the root of a deep structure embracing the parent-chaining pattern for readability. The API contains a lot of extension points to add specific behaviors.","title":"Package dev.jeka.core.api.project"},{"location":"reference-guide/build-library-project-build/#project-structure","text":"JkProject structure project +- baseDir +- outputDir +- artifactProducer (define artifacts procuded by the build) +- duplicateDependencyConflictStrategy +- jvmTargetVersion +- sourceEncoding +- javaCompiler +- dependencyResolver +- prodCompilation (produce individual binary files from production sources. This includes resource processing, code generation, processing on .class files, ...) | +- layout (where are located source and resource files) | +- source generators (plugin mechanism for generating source files) | +- dependencies (stands for compile dependencies) | +- preCompileActions (including resources processing) | +- compileActions (including java sources compilation. Compilation for other languages can be added here) | +- postCompileActions | +- methods : resolveDependencies(), run() +- testing | +- testCompilation (same as above 'prodcCompilation' but for test sources) | | +- layout | | +- dependencies (stands for test dependencies) | | + ... | +- breakOnFailure (true/false) | +- skipped (true/false) | +- testProcessor | | +- forkedProcess (configured the forked process who will run tests) | | +- preActions | | +- postActions | | +- engineBehavior | | | +- testReportDir | | | +- progressDisplayer | | | +- launcherConfiguration (based on junit5 platform API) | | +- testSelection | | | +- includePatterns | | | +- includeTags | +- method : run() +- packaging (produces javadoc and source jar and bin jars) | +- javadocConfiguration | +- runtimeDependencies | +- manifest | +- fatJar (customize produced fat/uber jar if any) | +- methods : createJavadocJar(), createSourceJar(), createBinJar(), createFatJar(), resolveRuntimeDependencies() +- publication (define information about module and artifacts to be published) | +- moduleId (group:name) | +- version | +- maven (maven specific information to be published in a Maven Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- mavenSpecificInfo | | +- method : publish() | +- ivy (Ivy specific information to be published in a Ivy Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- ivySpecifictInfo | | +- method : publish() | +- methods : publish(), getVersion(), getModuleId() + methods : getArtifacctPath(artifactName), toDependency(transitivity), getIdeSupport(), pack(), +- methods : getDependenciesAsXml(), includeLocalAndTextDependencies() For convenience, JkProject provides a facade in order to make common settings friendly, without navigating deep into the structure. From facade, you can setup dependencies, java version, project layout, test behavior, test selection and publication. JkProject . of (). flatFacade () . configureCompileDependencies ( deps -> deps . and ( \"com.google.guava:guava:21.0\" ) . and ( \"com.sun.jersey:jersey-server:1.19.4\" ) . and ( \"org.junit.jupiter:junit-jupiter-engine:5.6.0\" )) . configureRuntimeDependencies ( deps -> deps . minus ( \"org.junit.jupiter:junit-jupiter-engine\" ) . and ( \"com.github.djeang:vincer-dom:1.2.0\" )) . configureTestDependencies ( deps -> deps . and ( \"org.junit.vintage:junit-vintage-engine:5.6.0\" )) . addTestExcludeFilterSuffixedBy ( \"IT\" , false ) . setJavaVersion ( JkJavaVersion . V8 ) . setPublishedModuleId ( \"dev.jeka:sample-javaplugin\" ) . setPublishedVersion ( \"1.0-SNAPSHOT\" ); If facade is not sufficient for setting up the project build, you can use the main API. JkProject instances are highly configurable. Here is a pretty complete example inspired from the Jeka Build Class .","title":"Project Structure"},{"location":"reference-guide/build-library-project-build/#dependencies","text":"Project dependencies are managed differently than in Maven/Gradle. Instead of defining a single collection of dependencies, each bounded for a specific scope/configuration, Jeka projects define 3 distinct classpath : compile, runtime and test. Each classpath defines its own set of dependencies independently tough they are defined relatively to each other. Compile classpath : is defined using project.getCompilation().configureDependencies() . Runtime classpath : is defined from Compile Classpath . This base can be modified using project.packaging.configureDependencies() . Test classpath : is defined from a merge of Compile Classpath and Runtime Classpath . This base can be modified using project.getTesing().getCompilation().configureDependencies()","title":"Dependencies"},{"location":"reference-guide/build-library-project-build/#full-text-description","text":"An entire project dependency sets can be declared with full text description. For this, just pass a string argument to JkDependencySet#ofTextDescription describing the module dependencies. When using ProjectJkBean , the content of the file jeka/libs/dependencies.txt is automatically added to the project dependencies, tough it can be modified programmatically. Dependencies have to be declared with format group:module:[classifier]:[type]:[version] where classifier , type and version' are optional. See `JkCoordinate.of(String description) for details. To import bill-of-materials (aka BOMs) just declare a dependency as '*group:module::pom:version' Example == COMPILE == org.lwjgl:lwjgl-bom::pom:3.3.1 # Use lwjgl BOM so we don't need to specify lwjgl versions afterward org.lwjgl:lwjgl:natives-linux:: # specify the 'natives-linux' classifier for lwjgl org.projectlombok:lombok:1.16.16 == RUNTIME == org.postgresql:postgresql:42.5.0 - org.projectlombok:lombok # remove lombok from runtime dependencies == TEST == org.seleniumhq.selenium:selenium-chrome-driver:3.4.0 org.fluentlenium:fluentlenium-junit:3.2.0 @ org.apache.httpcomponents:httpclient # exclude http-client from fluentlenium-junit transitive dependencies org.fluentlenium:fluentlenium-assertj:3.2.0 @@ net.sourceforge.htmlunit:htmlunit # exclude htmlunit from all transitive dependencies == COMPILE == Defines dependencies that will constitute the compile classpath. == RUNTIME == Defines dependencies that will constitute the runtime classpath. The dependencies will be the ones declared in == COMPILE == section plus the ones declared in == RUNTIME == section. If dependencies declared in == compile == section should not be included for runtime classpath, it should be explicitly be removed using '-' symbol. == TEST == Defines dependencies that will constitute the test classpath. The dependencies will be the ones declared in == COMPILE == or == RUNTIME == sections (merge) plus the ones declared in == TEST == section. Tip If you are using Jeka plugin for Intellij, hit ctrl+<space> for displaying suggestions.","title":"Full Text Description"},{"location":"reference-guide/build-library-project-build/#publication","text":"Projects can be published on a binary repositories (as Maven or Ivy repo) using project.getPubliication().publish() . When this method is invoked, all artifacts defined in the projects are published. Artifacts can be binary, sources, javadoc or any kind of file. When published on repository, a metadata file is generated mentioning moduleId, version and transitive dependencies. Transitive dependencies are inferred from compile and runtime dependencies declared for the project, tough it can be modified programmatically using respectively project.getPublication().getMaven().configureDependencies() and project.getPublication().getIvy().configureDependencies() .","title":"Publication"},{"location":"reference-guide/build-library-system/","text":"The dev.jeka.core.api.system package provides system level functions : JkInfo Provides meta information as the running version of Jeka. JkLocator Provides information about where is located repository cache or Jeka user home. JkLog Provides API to log Jeka event. It supports hierarchical logs through #startTask and #endtask methods. JkProcess Launcher for external process. JkPrompt One-liner to ask user input.","title":"System"},{"location":"reference-guide/build-library/","text":"The Build Library \u00b6 Jeka contains a library for all regular things you need to build/test/publish projects.. The library does not depend on the execution engine and has zero dependency. API Style \u00b6 Jeka tries to stick with a consistent API design style. All Jeka public classes/interfaces start with Jk . The reason is for easing distinction, in IDE, between classes supposed be used in production or test and the ones used for building. It also helps to explore Jeka API. As a rule of thumb Jeka favors immutable objects for shallow structures and parent-chaining trees for deeper ones. Both provide a fluent interface when possible. All objects are instantiated using static factory methods. Every factory method names start with of . All accessor method names (methods returning a result without requiring IO, only computation) starts with get . To create a subtly different object from another immutable one, Jeka provides : Methods starting with with when a property is to be replaced by another. Methods starting with and when a collection property is to be replaced by the same one plus an extra element. Methods starting with minus when a collection property is to be replaced by the same one minus a specified element. To modify a mutable object, Jeka provides : Methods starting with set to replace a single property value by another. Methods starting with add to add a value to a collection property. Those methods return the object itself for chaining. Domains Covered by the API \u00b6 The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API relies on other lower level ones provided by Jeka . In a glance these are the domains covered by the Jeka APIs : Files : File trees, filters, zip, path sequence System : Launching external process, Logging, Meta-info Cryptography : PGP signer Dependency management : Dependency management, publishing on repositories Java : Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching Testing : Launching tests and get reports Project : Project structure to build Tooling : Eclipse integration, intellij integration, Maven interaction, Git Support : Set of utility class with static methods to handle low-level concerns Files \u00b6 File manipulation is a central part for building software. Jeka embraces JDK7 java.nio.file API by adding some concepts around, to provide a powerful fluent style API performing recurrent tasks with minimal effort. The following classes lie in dev.jeka.core.api.file package: JkPathFile A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods. JkPathSequence An Immutable sequence of java.nio.file.Path providing methods for filtering or appending. JkPathMatcher An immutable java.nio.file.PathMatcher based on java.nio.file glob pattern or regerxp. Used by JkPathTree to filter in/out files according name patterns. JkPathTree An Immutable root folder (or a zip file) along a PathMatcher providing operations to copy, navigate, zip or iterate. This is a central class in Jeka API. JkPathTreeSet An Immutable set of JkPathTree . Helpful to define set of sources/resources and create jar/zip files. JkResourceProcessor A mutable processor for copying a set of files, preserving the structure and replacing some text by other text. Typically, used for replacing token as ${server.ip} by an actual value. Examples // creates a file and writes the content of the specified url. JkPathFile . of ( \"config/my-config.xml\" ). createIfNotExist (). replaceContentBy ( \"http://myserver/conf/central.xml\" ); // copies all non java source files to another directory preserving structure JkPathTree . of ( \"src\" ). andMatching ( false , \"**/*.java\" ). copyTo ( \"build/classes\" ); // One liner to zip an entire directory JkPathTree . of ( \"build/classes\" ). zipTo ( Paths . get ( \"mylib.jar\" )); System \u00b6 The dev.jeka.core.api.system package provides system level functions : JkInfo Provides meta information as the running version of Jeka. JkLocator Provides information about where is located repository cache or Jeka user home. JkLog Provides API to log Jeka event. It supports hierarchical logs through #startTask and #endtask methods. JkProcess Launcher for external process. JkPrompt One-liner to ask user input. Dependency Management \u00b6 Dependency management API let define, fetch and publish dependencies. Api classes belong to dev.jeka.core.api.depmanagement package Concepts \u00b6 Dependency \u00b6 For Jeka, a dependency is something that can be resolved to a set of files by a JkDependencyResolver . Generally a dependency resolves to 1 file (or folder) but it can be 0 or many. A dependency is always an instance of JkDependency . Jeka distinguishes mainly 3 types of dependency : Arbitrary files located on the file system (represented by JkFileSystemDependency class). These files are assumed to be present on the file system when the build is running. Files produced by a computation (represented by JkComputedDependency class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project. Reference to module (represented by JkModuleDependency ) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and resolve transitively any artifact located in a repository as you would do with Maven, Ivy or Gradle. For the last, Jeka is using Ivy 2.5.0 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code. JkModuleDependencies (dependency on module through coordinates) This is for declaring a dependency on module hosted in Maven or Ivy repository. Basically you instantiate a JkModuleDepency from it's group, name and version. JkDependencySet . of () . and ( JkPopularModule . GUAVA , \"18.0\" ) . and ( \"com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[\" ) . and ( \"mygroup:mymodule:myclassifier:0.2-SNAPSHOT\" ); There is many way to indicate a module dependency, see Javadoc for browsing possibilities. Note that : A version ending by -SNAPSHOT has a special meaning : Jeka will consider it \"changing\" . This means that it won't cache it locally and will download the latest version from repository. As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned here . Dependency files are downloaded in [USER HOME] /.jeka/cache/repo JkFileSystemSependency (dependency on local files) Just mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails. JkDependencySet . of (). andFiles ( \"libs/my.jar\" , \"libs/my.testingtool.jar\" ); JkComputedDependenciy (dependency on files produced by computation) It is typically used for multi-modules or multi-techno projects. The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails. This mechanism is quite simple yet powerful as it addresses following use cases : Dependencies on files produced by an artifact producer ( JkArtifactProducer ). A JkProject is an artifact producer. Dependencies on files produced by external build tool (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...). ... In other words, files produced by any means. The generic way is to construct this kind of dependency using a java.lang.Runnable . The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka . Path mavenProject = Paths . get ( \"../a-maven-project\" ); JkProcess mavenBuild = JkProcess . of ( \"mvn\" , \"clean\" , \"install\" ). withWorkingDir ( mavenProject ); Path mavenProjectJar = mavenProject . resolve ( \"target/maven-project.jar\" ); JkJavaProject externalProject = JkJavaProject . ofSimple ( Paths . get ( \"../a-jeka-project\" )); JkDependencySet deps = JkDependencySet . of () . and ( JkComputedDependency . of ( mavenBuild , mavenProjectJar )) . and ( externalProject ); DependencySet \u00b6 A dependencySet ( JkDependencySet ) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of JkDependency . See here dependencySet also defines : A version provider to define which version of a module we should use in case it is not explicitly mentioned. It is possible to populate a version provider by passing a BOM coordinate. A set of transitive dependency exclusion rules. It is designed as an immutable object where we can apply set theory operations for adding, removing or merging with other dependencies and dependencySet . Example of dependency set JkDependencySet deps = JkDependencySet . of () . and ( \"com.google.guava\" ) . and ( \"org.slf4j:slf4j-simple\" ) . and ( \"com.orientechnologies:orientdb-client:2.0.8\" ) . andFile ( \"../libs.myjar\" ) . withVersionProvider ( myVersionProvider ); Note that : Module version and scopes can be omitted when declaring dependencies. Versions can be provided by a JkVersionProvider . Instances of JkDependencySet can be combined together in order to construct large dependencySet from smaller ones. JkDependencySet#ofTextDescription provides a mean to instantiate a dependency set from a simple text. Example of text describing dependencies - COMPILE+RUNTIME org.springframework.boot:spring-boot-starter-thymeleaf org.springframework.boot:spring-boot-starter-data-jpa - RUNTIME com.h2database:h2 org.liquibase:liquibase-core com.oracle:ojdbc6:12.1.0 - TEST org.springframework.boot:spring-boot-starter-test org.seleniumhq.selenium:selenium-chrome-driver:3.4.0 org.fluentlenium:fluentlenium-assertj:3.2.0 org.fluentlenium:fluentlenium-junit:3.2.0 - COMPILE org.projectlombok:lombok:1.16.16 Transiitivity \u00b6 Mainstream build tools use a single concept ('scope' or 'configuration') to determine both : Which part of the build needs the dependency Which transitive dependencies to fetch along the dependency. If the dependency must be part of the transitive dependencies according a configuration. This confusion leads in dependency management systems that are bloated, difficult to reason about and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a fewer but with limitations and not-so-clear transitivity/publish rules. In the opposite, Jeka distinguishes clearly the three purposes : Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be defined relatively to another using set theory operations. For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency. For publishing, we can optionally re-define a specific dependencySet , exposing exactly what we want. Jeka defines by default, 3 levels of transitivity : NONE : Not transitive COMPILE : Also fetch transitive dependencies declared with scope 'compile' in the dependency published pom. RUNTIME : Also fetch transitive dependencies declared with any scope in the dependency published pom. Reminder : on Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'. For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'. The below example shows a JkJavaProject declaration using explicit transitivity. JkJavaProject . of (). simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:23.0\" , JkTransitivity . NONE ) . and ( \"javax.servlet:javax.servlet-api:4.0.1\" )) . configureRuntimeDeps ( deps -> deps . and ( \"org.postgresql:postgresql:42.2.19\" ) . withTransitivity ( \"com.google.guava:guava\" , JkTransitivity . RUNTIME ) . minus ( \"javax.servlet:javax.servlet-api\" )) . configureTestDeps ( deps -> deps . and ( Hint . first (), \"org.mockito:mockito-core:2.10.0\" ) ) It results in : Declared Compile Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:NONE javax.servlet:javax.servlet-api:4.0.1 Declared Runtime Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 Declared Test Dependencies : 4 elements. org.mockito:mockito-core:2.10.0 com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 javax.servlet:javax.servlet-api:4.0.1 Dependencies without any transitivity specified on, will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies. The API allows to redefine the transitivity declared in a upper dependency set. Note that transitivity can only apply to JkModuleDependency (like com.google.guava:guava:23.0 ) and JkLocalProjectDependency . Resolve Dependencies \u00b6 The JkDependencyResolver class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning JkResolveResult from a JkdependencySet . JkDependencySet deps = JkDependencySet . of ( \"org.apache.httpcomponents:httpclient:4.5.3\" ) . andFile ( \"libs/my.jar\" ); // Here, module dependencies are fetched from Maven central repo JkDependencyResolver resolver = JkDependencyResolver . of ( JkRepo . ofMavenCentral ()); JkResolveResult result = resolver (). resolve ( deps ); From the result you can : Navigate in the resolved dependency tree as : JkDependencyNode slfjApiNodeDep = result . getDependencyTree (). getFirst ( JkModuleId . of ( \"org.slf4j:slf4j-api\" )); System . out . println ( slfjApiNode . getModuleInfo (). getResolvedVersion ()); Get the direct list of artifact files JkPathSequence sequence = result . getFiles (); sequence . forEach ( System . out :: println ); // print each files part of the dependency resolution Publication \u00b6 Jeka is able to publish on both Maven and Ivy repository. This includes repositories as Sonatype Nexus . Maven and Ivy have different publication model, so Jeka proposes specific APIs according you want to publish on a Maven or Ivy repository. Publish to a Maven repository \u00b6 Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according provided elements. The following snippet demonstrate a pretty sophisticated publishing on Maven : JkVersionedModule versionedModule = JkVersionedModule . of ( \"org.myorg:mylib:1.2.6\" ); JkDependencySet deps = JkDependencySet . of () . and ( \"org.slf4j:slf4j-simple\" , COMPILE_AND_RUNTIME ) . and ( \"junit:junit:4.11\" , TEST ); JkMavenPublication mavenPublication = JkMavenPublication . of ( Paths . get ( \"org.myorg.mylib.jar\" )) // the following are optional but required to publish on public repositories. . and ( Paths . get ( \"org.myorg.mylib-sources.jar\" ), \"sources\" ) . and ( Paths . get ( \"org.myorg.mylib-javadoc.jar\" ), \"javadoc\" ) . withChecksums ( \"sha-2\" , \"md5\" ) . withSigner ( JkPgp . of ( Paths . get ( \"myPubring\" ), Paths . get ( \"mySecretRing\" ), \"mypassword\" )) . with ( JkMavenPublicationInfo . of ( \"My sample project\" , \"A project to demonstrate publishing on Jeka\" , \"http://project.jeka.org\" ) . andApache2License () . andDeveloper ( \"djeang\" , \"myemail@gmail.com\" , \"jeka.org\" , \"http://project.jeka.org/\" )); // A complex case for repo (credential + signature + filtering) JkRepo repo = JkRepo . of ( \"http://myserver/myrepo\" ) . withOptionalCredentials ( \"myUserName\" , \"myPassword\" ) . with ( JkRepo . JkPublishConfig . of () . withUniqueSnapshot ( false ) . withNeedSignature ( true ) . withFilter ( mod -> // only accept SNAPSHOT and MILESTONE mod . getVersion (). isSnapshot () || mod . getVersion (). getValue (). endsWith ( \"MILESTONE\" ) )); // Actually publish the artifacts JkPublisher publisher = JkPublisher . of ( repo ); publisher . publishMaven ( versionedModule , mavenPublication , deps ); Notice that Jeka allows to : Publish more than one artifact. Produce & publish checksum files for each published artifact. Mention to use unique snapshot ( What is it ? ). Feed generated pom with data necessary to publish on central repository . Sign published artifact with PGP Publish to multiple repository by creating the publisher using a JkRepoSet instead of a JkRepo . To sign with PGP, no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts. Publish to a Ivy repository \u00b6 Publishing on Ivy repo is pretty similar than on Maven though there is specific options to Ivy. JkVersionedModule versionedModule = JkVersionedModule . of ( \"org.myorg:mylib:1.2.6-SNAPSHOT\" ); JkDependencySet deps = JkDependencySet . of () . and ( \"org.slf4j:slf4j-simple\" , COMPILE_AND_RUNTIME ) . and ( \"junit:junit:4.11\" , TEST ); JkIvyPublication publication = JkIvyPublication . of ( Paths . get ( \"org.myorg.mylib.jar\" ), \"master\" ) . and ( Paths . get ( \"org.myorg.mylib-sources.jar\" )); JkRepo repo = JkRepo . ofIvy ( Paths . get ( \"ivyrepo\" )); JkPublisher publisher = JkPublisher . of ( repo ); publisher . publishIvy ( versionedModule , publication , deps , JkJavaDepScopes . DEFAULT_SCOPE_MAPPING , Instant . now (), JkVersionProvider . of ()); Project Building \u00b6 Jeka features high-level and low-level classes to deal with Java builds and JVM concepts. Java Tool Base API \u00b6 Base classes are used as foundation for implementing Jeka high-level build API but they can be used directly in a low level build description. These classes belong to dev.jeka.core.api.java package . JkClassLoader and JkUrlClassloader Wrap a java.lang.ClassLoader adding convenient methods and classpath scanning capability. JkJarPacker A simple utility tyo create Jar or fat Jar file from compiled classes. JkJavaCompiler Wraps either a Java Compiler tool, nor a javac process. JkJavadocProcessor A Java source processor producing standard Javadoc JkJavaProcess A utility to launch Java process (from class dirs or jars) JkManifest Stands for the manifest file to include in jar files. Testing API \u00b6 Jeka features a simple yet powerful API to launch tests. It relies entirely on JUnit5. This means that any test framework supported by Junit5 platform. Jeka testing API mostly hides Junit Platform . For most of the cases, you won't need to code against Junit-Platform API to launch tests with Jeka. Nevertheless, Jeka allows users to code against Junit-Platform for fine-tuning. The API classes all belongs to dev.jeka.core.api.java.testing package . JkTestProcessor This is the entry point to launch tests. Tests are executed using the current classloader classpath + extra class path mentioned in #launch method arguments. JkTestResult The result of a test launch : count for found, failure, skip, success ... JkTestSelection A mean to determine which test to launch. It can be set using file or tag filter. It is also possible to code against JUnit Platform Project API \u00b6 This is the Jeka high-level API to build Java/JVM projects. API classes belong to dev.jeka.core.api.project package . It introduces the concept of JkProject from where is performed compilation, testing, resources processing, packaging, publication and more. JkProject is the root of a deep structure embracing the parent-chaining pattern for readability. The API contains a lot of extension points to add specific behaviors. Project API structure project +- baseDir +- outputDir +- artifactProducer (define artifacts to be produce by the build as map of artifactName -> Consumer<Path> producing the artifact) +- duplicateDependencyConflictStrategy +- construction (Produce packaged binaries from sources. This includes test checking) | +- jvmTargetVersion | +- sourceEncoding | +- javaCompiler | +- dependencyResolver | +- runtimeDependencies | +- manifest | +- fatJar (customize produced fat/uber jar if any) | +- compilation (produce individual binary files from production sources. This includes resource processing, code generation, transpiling, post binary processing, ...) | | +- layout (where are located source and resource files) | | +- dependencies (stands for compile dependencies) | | +- preCompileActions (including resources processing) | | +- compileActions (including java sources compilation. Compilation for other languages can be added here) | | +- postCompileActions | | +- methods : resolveDependencies(), run() | +- testing | | +- compilation (same as above 'compilation' but for test sources/resources) | | | +- layout | | | +- dependencies (stands for test dependencies) | | | + ... | | +- breakOnFailure (true/false) | | +- skipped (true/false) | | +- testProcessor | | | +- forkedProcess (configured the forked process who will run tests) | | | +- preActions | | | +- postActions | | | +- engineBehavior | | | | +- progressDisplayer | | | | +- launcherConfiguration (based on junit5 platform API) | | | +- testSelection | | | | +- includePatterns | | | | +- includeTags | | +- method : run() | +- methods : createBinJar(), createFatJar(), resolveRuntimeDependencies(), getDependenciesAsXml() | + includeLocalDependencies(), includeTextDependencies() +- documentation (mainly procude javadoc and source jar) | +- javadocConfiguration | +- methods : createJavadocJar(), createSourceJar(), run() +- publication (define information about module and artifacts to be published) | +- moduleId (group:name) | +- version | +- maven (maven specific information to be published in a Maven Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- mavenSpecificInfo | | +- methods : publish | +- ivy (Ivy specific information to be published in a Ivy Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- ivySpecifictInfo | | +- method : publish() | +- methods : publish(), getVersion(), getModuleId() + methods : getArtifacctPath(artifactName), toDependency(transitivity), getIdeSupport(), pack() For simplicity\u2019s sake, JkProject provides a facade in order to setup common settings friendly, without navigating deep into the structure. From facade, you can setup dependencies, java version, project layout, test behavior, test selection and publication. JkProject . of (). simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:21.0\" ) . and ( \"com.sun.jersey:jersey-server:1.19.4\" ) . and ( \"org.junit.jupiter:junit-jupiter-engine:5.6.0\" )) . configureRuntimeDeps ( deps -> deps . minus ( \"org.junit.jupiter:junit-jupiter-engine\" ) . and ( \"com.github.djeang:vincer-dom:1.2.0\" )) . configureTestDeps ( deps -> deps . and ( \"org.junit.vintage:junit-vintage-engine:5.6.0\" )) . addTestExcludeFilterSuffixedBy ( \"IT\" , false ) . setJavaVersion ( JkJavaVersion . V8 ) . setPublishedModuleId ( \"dev.jeka:sample-javaplugin\" ) . setPublishedVersion ( \"1.0-SNAPSHOT\" ); If facade is not sufficient for setting up project build, it's still possible to complete through the main API. JkProject instances are highly configurable. Here is a pretty complete example inspired from the Jeka Build Class . Third Party Tool Integration \u00b6 The dev.jeka.core.api.tooling package provides integration with tools developers generally deal with. Eclipse \u00b6 JkEclipseClasspathGenerator and JkEclipseProjectGenerator provides method to generate a proper .classpath and .project file respectively. JkEclipseClasspathApplier reads information from a .classpath file. Intellij \u00b6 JkIntellijImlGenerator generates proper .iml files. Git \u00b6 JkGitWrapper wraps common Git commands in a lean API. Maven \u00b6 JkMvn wraps Maven command line in a lean API JkPom reads POM/BOM to extract information like : declared dependencies, dependency management, repos, properties, version and artifactId.","title":"The Build Library"},{"location":"reference-guide/build-library/#the-build-library","text":"Jeka contains a library for all regular things you need to build/test/publish projects.. The library does not depend on the execution engine and has zero dependency.","title":"The Build Library"},{"location":"reference-guide/build-library/#api-style","text":"Jeka tries to stick with a consistent API design style. All Jeka public classes/interfaces start with Jk . The reason is for easing distinction, in IDE, between classes supposed be used in production or test and the ones used for building. It also helps to explore Jeka API. As a rule of thumb Jeka favors immutable objects for shallow structures and parent-chaining trees for deeper ones. Both provide a fluent interface when possible. All objects are instantiated using static factory methods. Every factory method names start with of . All accessor method names (methods returning a result without requiring IO, only computation) starts with get . To create a subtly different object from another immutable one, Jeka provides : Methods starting with with when a property is to be replaced by another. Methods starting with and when a collection property is to be replaced by the same one plus an extra element. Methods starting with minus when a collection property is to be replaced by the same one minus a specified element. To modify a mutable object, Jeka provides : Methods starting with set to replace a single property value by another. Methods starting with add to add a value to a collection property. Those methods return the object itself for chaining.","title":"API Style"},{"location":"reference-guide/build-library/#domains-covered-by-the-api","text":"The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API relies on other lower level ones provided by Jeka . In a glance these are the domains covered by the Jeka APIs : Files : File trees, filters, zip, path sequence System : Launching external process, Logging, Meta-info Cryptography : PGP signer Dependency management : Dependency management, publishing on repositories Java : Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching Testing : Launching tests and get reports Project : Project structure to build Tooling : Eclipse integration, intellij integration, Maven interaction, Git Support : Set of utility class with static methods to handle low-level concerns","title":"Domains Covered by the API"},{"location":"reference-guide/build-library/#files","text":"File manipulation is a central part for building software. Jeka embraces JDK7 java.nio.file API by adding some concepts around, to provide a powerful fluent style API performing recurrent tasks with minimal effort. The following classes lie in dev.jeka.core.api.file package: JkPathFile A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods. JkPathSequence An Immutable sequence of java.nio.file.Path providing methods for filtering or appending. JkPathMatcher An immutable java.nio.file.PathMatcher based on java.nio.file glob pattern or regerxp. Used by JkPathTree to filter in/out files according name patterns. JkPathTree An Immutable root folder (or a zip file) along a PathMatcher providing operations to copy, navigate, zip or iterate. This is a central class in Jeka API. JkPathTreeSet An Immutable set of JkPathTree . Helpful to define set of sources/resources and create jar/zip files. JkResourceProcessor A mutable processor for copying a set of files, preserving the structure and replacing some text by other text. Typically, used for replacing token as ${server.ip} by an actual value. Examples // creates a file and writes the content of the specified url. JkPathFile . of ( \"config/my-config.xml\" ). createIfNotExist (). replaceContentBy ( \"http://myserver/conf/central.xml\" ); // copies all non java source files to another directory preserving structure JkPathTree . of ( \"src\" ). andMatching ( false , \"**/*.java\" ). copyTo ( \"build/classes\" ); // One liner to zip an entire directory JkPathTree . of ( \"build/classes\" ). zipTo ( Paths . get ( \"mylib.jar\" ));","title":"Files"},{"location":"reference-guide/build-library/#system","text":"The dev.jeka.core.api.system package provides system level functions : JkInfo Provides meta information as the running version of Jeka. JkLocator Provides information about where is located repository cache or Jeka user home. JkLog Provides API to log Jeka event. It supports hierarchical logs through #startTask and #endtask methods. JkProcess Launcher for external process. JkPrompt One-liner to ask user input.","title":"System"},{"location":"reference-guide/build-library/#dependency-management","text":"Dependency management API let define, fetch and publish dependencies. Api classes belong to dev.jeka.core.api.depmanagement package","title":"Dependency Management"},{"location":"reference-guide/build-library/#concepts","text":"","title":"Concepts"},{"location":"reference-guide/build-library/#dependency","text":"For Jeka, a dependency is something that can be resolved to a set of files by a JkDependencyResolver . Generally a dependency resolves to 1 file (or folder) but it can be 0 or many. A dependency is always an instance of JkDependency . Jeka distinguishes mainly 3 types of dependency : Arbitrary files located on the file system (represented by JkFileSystemDependency class). These files are assumed to be present on the file system when the build is running. Files produced by a computation (represented by JkComputedDependency class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project. Reference to module (represented by JkModuleDependency ) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and resolve transitively any artifact located in a repository as you would do with Maven, Ivy or Gradle. For the last, Jeka is using Ivy 2.5.0 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code. JkModuleDependencies (dependency on module through coordinates) This is for declaring a dependency on module hosted in Maven or Ivy repository. Basically you instantiate a JkModuleDepency from it's group, name and version. JkDependencySet . of () . and ( JkPopularModule . GUAVA , \"18.0\" ) . and ( \"com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[\" ) . and ( \"mygroup:mymodule:myclassifier:0.2-SNAPSHOT\" ); There is many way to indicate a module dependency, see Javadoc for browsing possibilities. Note that : A version ending by -SNAPSHOT has a special meaning : Jeka will consider it \"changing\" . This means that it won't cache it locally and will download the latest version from repository. As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned here . Dependency files are downloaded in [USER HOME] /.jeka/cache/repo JkFileSystemSependency (dependency on local files) Just mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails. JkDependencySet . of (). andFiles ( \"libs/my.jar\" , \"libs/my.testingtool.jar\" ); JkComputedDependenciy (dependency on files produced by computation) It is typically used for multi-modules or multi-techno projects. The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails. This mechanism is quite simple yet powerful as it addresses following use cases : Dependencies on files produced by an artifact producer ( JkArtifactProducer ). A JkProject is an artifact producer. Dependencies on files produced by external build tool (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...). ... In other words, files produced by any means. The generic way is to construct this kind of dependency using a java.lang.Runnable . The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka . Path mavenProject = Paths . get ( \"../a-maven-project\" ); JkProcess mavenBuild = JkProcess . of ( \"mvn\" , \"clean\" , \"install\" ). withWorkingDir ( mavenProject ); Path mavenProjectJar = mavenProject . resolve ( \"target/maven-project.jar\" ); JkJavaProject externalProject = JkJavaProject . ofSimple ( Paths . get ( \"../a-jeka-project\" )); JkDependencySet deps = JkDependencySet . of () . and ( JkComputedDependency . of ( mavenBuild , mavenProjectJar )) . and ( externalProject );","title":"Dependency"},{"location":"reference-guide/build-library/#dependencyset","text":"A dependencySet ( JkDependencySet ) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of JkDependency . See here dependencySet also defines : A version provider to define which version of a module we should use in case it is not explicitly mentioned. It is possible to populate a version provider by passing a BOM coordinate. A set of transitive dependency exclusion rules. It is designed as an immutable object where we can apply set theory operations for adding, removing or merging with other dependencies and dependencySet . Example of dependency set JkDependencySet deps = JkDependencySet . of () . and ( \"com.google.guava\" ) . and ( \"org.slf4j:slf4j-simple\" ) . and ( \"com.orientechnologies:orientdb-client:2.0.8\" ) . andFile ( \"../libs.myjar\" ) . withVersionProvider ( myVersionProvider ); Note that : Module version and scopes can be omitted when declaring dependencies. Versions can be provided by a JkVersionProvider . Instances of JkDependencySet can be combined together in order to construct large dependencySet from smaller ones. JkDependencySet#ofTextDescription provides a mean to instantiate a dependency set from a simple text. Example of text describing dependencies - COMPILE+RUNTIME org.springframework.boot:spring-boot-starter-thymeleaf org.springframework.boot:spring-boot-starter-data-jpa - RUNTIME com.h2database:h2 org.liquibase:liquibase-core com.oracle:ojdbc6:12.1.0 - TEST org.springframework.boot:spring-boot-starter-test org.seleniumhq.selenium:selenium-chrome-driver:3.4.0 org.fluentlenium:fluentlenium-assertj:3.2.0 org.fluentlenium:fluentlenium-junit:3.2.0 - COMPILE org.projectlombok:lombok:1.16.16","title":"DependencySet"},{"location":"reference-guide/build-library/#transiitivity","text":"Mainstream build tools use a single concept ('scope' or 'configuration') to determine both : Which part of the build needs the dependency Which transitive dependencies to fetch along the dependency. If the dependency must be part of the transitive dependencies according a configuration. This confusion leads in dependency management systems that are bloated, difficult to reason about and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a fewer but with limitations and not-so-clear transitivity/publish rules. In the opposite, Jeka distinguishes clearly the three purposes : Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be defined relatively to another using set theory operations. For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency. For publishing, we can optionally re-define a specific dependencySet , exposing exactly what we want. Jeka defines by default, 3 levels of transitivity : NONE : Not transitive COMPILE : Also fetch transitive dependencies declared with scope 'compile' in the dependency published pom. RUNTIME : Also fetch transitive dependencies declared with any scope in the dependency published pom. Reminder : on Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'. For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'. The below example shows a JkJavaProject declaration using explicit transitivity. JkJavaProject . of (). simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:23.0\" , JkTransitivity . NONE ) . and ( \"javax.servlet:javax.servlet-api:4.0.1\" )) . configureRuntimeDeps ( deps -> deps . and ( \"org.postgresql:postgresql:42.2.19\" ) . withTransitivity ( \"com.google.guava:guava\" , JkTransitivity . RUNTIME ) . minus ( \"javax.servlet:javax.servlet-api\" )) . configureTestDeps ( deps -> deps . and ( Hint . first (), \"org.mockito:mockito-core:2.10.0\" ) ) It results in : Declared Compile Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:NONE javax.servlet:javax.servlet-api:4.0.1 Declared Runtime Dependencies : 2 elements. com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 Declared Test Dependencies : 4 elements. org.mockito:mockito-core:2.10.0 com.google.guava:guava:23.0 transitivity:RUNTIME org.postgresql:postgresql:42.2.19 javax.servlet:javax.servlet-api:4.0.1 Dependencies without any transitivity specified on, will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies. The API allows to redefine the transitivity declared in a upper dependency set. Note that transitivity can only apply to JkModuleDependency (like com.google.guava:guava:23.0 ) and JkLocalProjectDependency .","title":"Transiitivity"},{"location":"reference-guide/build-library/#resolve-dependencies","text":"The JkDependencyResolver class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning JkResolveResult from a JkdependencySet . JkDependencySet deps = JkDependencySet . of ( \"org.apache.httpcomponents:httpclient:4.5.3\" ) . andFile ( \"libs/my.jar\" ); // Here, module dependencies are fetched from Maven central repo JkDependencyResolver resolver = JkDependencyResolver . of ( JkRepo . ofMavenCentral ()); JkResolveResult result = resolver (). resolve ( deps ); From the result you can : Navigate in the resolved dependency tree as : JkDependencyNode slfjApiNodeDep = result . getDependencyTree (). getFirst ( JkModuleId . of ( \"org.slf4j:slf4j-api\" )); System . out . println ( slfjApiNode . getModuleInfo (). getResolvedVersion ()); Get the direct list of artifact files JkPathSequence sequence = result . getFiles (); sequence . forEach ( System . out :: println ); // print each files part of the dependency resolution","title":"Resolve Dependencies"},{"location":"reference-guide/build-library/#publication","text":"Jeka is able to publish on both Maven and Ivy repository. This includes repositories as Sonatype Nexus . Maven and Ivy have different publication model, so Jeka proposes specific APIs according you want to publish on a Maven or Ivy repository.","title":"Publication"},{"location":"reference-guide/build-library/#publish-to-a-maven-repository","text":"Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according provided elements. The following snippet demonstrate a pretty sophisticated publishing on Maven : JkVersionedModule versionedModule = JkVersionedModule . of ( \"org.myorg:mylib:1.2.6\" ); JkDependencySet deps = JkDependencySet . of () . and ( \"org.slf4j:slf4j-simple\" , COMPILE_AND_RUNTIME ) . and ( \"junit:junit:4.11\" , TEST ); JkMavenPublication mavenPublication = JkMavenPublication . of ( Paths . get ( \"org.myorg.mylib.jar\" )) // the following are optional but required to publish on public repositories. . and ( Paths . get ( \"org.myorg.mylib-sources.jar\" ), \"sources\" ) . and ( Paths . get ( \"org.myorg.mylib-javadoc.jar\" ), \"javadoc\" ) . withChecksums ( \"sha-2\" , \"md5\" ) . withSigner ( JkPgp . of ( Paths . get ( \"myPubring\" ), Paths . get ( \"mySecretRing\" ), \"mypassword\" )) . with ( JkMavenPublicationInfo . of ( \"My sample project\" , \"A project to demonstrate publishing on Jeka\" , \"http://project.jeka.org\" ) . andApache2License () . andDeveloper ( \"djeang\" , \"myemail@gmail.com\" , \"jeka.org\" , \"http://project.jeka.org/\" )); // A complex case for repo (credential + signature + filtering) JkRepo repo = JkRepo . of ( \"http://myserver/myrepo\" ) . withOptionalCredentials ( \"myUserName\" , \"myPassword\" ) . with ( JkRepo . JkPublishConfig . of () . withUniqueSnapshot ( false ) . withNeedSignature ( true ) . withFilter ( mod -> // only accept SNAPSHOT and MILESTONE mod . getVersion (). isSnapshot () || mod . getVersion (). getValue (). endsWith ( \"MILESTONE\" ) )); // Actually publish the artifacts JkPublisher publisher = JkPublisher . of ( repo ); publisher . publishMaven ( versionedModule , mavenPublication , deps ); Notice that Jeka allows to : Publish more than one artifact. Produce & publish checksum files for each published artifact. Mention to use unique snapshot ( What is it ? ). Feed generated pom with data necessary to publish on central repository . Sign published artifact with PGP Publish to multiple repository by creating the publisher using a JkRepoSet instead of a JkRepo . To sign with PGP, no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts.","title":"Publish to a Maven repository"},{"location":"reference-guide/build-library/#publish-to-a-ivy-repository","text":"Publishing on Ivy repo is pretty similar than on Maven though there is specific options to Ivy. JkVersionedModule versionedModule = JkVersionedModule . of ( \"org.myorg:mylib:1.2.6-SNAPSHOT\" ); JkDependencySet deps = JkDependencySet . of () . and ( \"org.slf4j:slf4j-simple\" , COMPILE_AND_RUNTIME ) . and ( \"junit:junit:4.11\" , TEST ); JkIvyPublication publication = JkIvyPublication . of ( Paths . get ( \"org.myorg.mylib.jar\" ), \"master\" ) . and ( Paths . get ( \"org.myorg.mylib-sources.jar\" )); JkRepo repo = JkRepo . ofIvy ( Paths . get ( \"ivyrepo\" )); JkPublisher publisher = JkPublisher . of ( repo ); publisher . publishIvy ( versionedModule , publication , deps , JkJavaDepScopes . DEFAULT_SCOPE_MAPPING , Instant . now (), JkVersionProvider . of ());","title":"Publish to a Ivy repository"},{"location":"reference-guide/build-library/#project-building","text":"Jeka features high-level and low-level classes to deal with Java builds and JVM concepts.","title":"Project Building"},{"location":"reference-guide/build-library/#java-tool-base-api","text":"Base classes are used as foundation for implementing Jeka high-level build API but they can be used directly in a low level build description. These classes belong to dev.jeka.core.api.java package . JkClassLoader and JkUrlClassloader Wrap a java.lang.ClassLoader adding convenient methods and classpath scanning capability. JkJarPacker A simple utility tyo create Jar or fat Jar file from compiled classes. JkJavaCompiler Wraps either a Java Compiler tool, nor a javac process. JkJavadocProcessor A Java source processor producing standard Javadoc JkJavaProcess A utility to launch Java process (from class dirs or jars) JkManifest Stands for the manifest file to include in jar files.","title":"Java Tool Base API"},{"location":"reference-guide/build-library/#testing-api","text":"Jeka features a simple yet powerful API to launch tests. It relies entirely on JUnit5. This means that any test framework supported by Junit5 platform. Jeka testing API mostly hides Junit Platform . For most of the cases, you won't need to code against Junit-Platform API to launch tests with Jeka. Nevertheless, Jeka allows users to code against Junit-Platform for fine-tuning. The API classes all belongs to dev.jeka.core.api.java.testing package . JkTestProcessor This is the entry point to launch tests. Tests are executed using the current classloader classpath + extra class path mentioned in #launch method arguments. JkTestResult The result of a test launch : count for found, failure, skip, success ... JkTestSelection A mean to determine which test to launch. It can be set using file or tag filter. It is also possible to code against JUnit Platform","title":"Testing API"},{"location":"reference-guide/build-library/#project-api","text":"This is the Jeka high-level API to build Java/JVM projects. API classes belong to dev.jeka.core.api.project package . It introduces the concept of JkProject from where is performed compilation, testing, resources processing, packaging, publication and more. JkProject is the root of a deep structure embracing the parent-chaining pattern for readability. The API contains a lot of extension points to add specific behaviors. Project API structure project +- baseDir +- outputDir +- artifactProducer (define artifacts to be produce by the build as map of artifactName -> Consumer<Path> producing the artifact) +- duplicateDependencyConflictStrategy +- construction (Produce packaged binaries from sources. This includes test checking) | +- jvmTargetVersion | +- sourceEncoding | +- javaCompiler | +- dependencyResolver | +- runtimeDependencies | +- manifest | +- fatJar (customize produced fat/uber jar if any) | +- compilation (produce individual binary files from production sources. This includes resource processing, code generation, transpiling, post binary processing, ...) | | +- layout (where are located source and resource files) | | +- dependencies (stands for compile dependencies) | | +- preCompileActions (including resources processing) | | +- compileActions (including java sources compilation. Compilation for other languages can be added here) | | +- postCompileActions | | +- methods : resolveDependencies(), run() | +- testing | | +- compilation (same as above 'compilation' but for test sources/resources) | | | +- layout | | | +- dependencies (stands for test dependencies) | | | + ... | | +- breakOnFailure (true/false) | | +- skipped (true/false) | | +- testProcessor | | | +- forkedProcess (configured the forked process who will run tests) | | | +- preActions | | | +- postActions | | | +- engineBehavior | | | | +- progressDisplayer | | | | +- launcherConfiguration (based on junit5 platform API) | | | +- testSelection | | | | +- includePatterns | | | | +- includeTags | | +- method : run() | +- methods : createBinJar(), createFatJar(), resolveRuntimeDependencies(), getDependenciesAsXml() | + includeLocalDependencies(), includeTextDependencies() +- documentation (mainly procude javadoc and source jar) | +- javadocConfiguration | +- methods : createJavadocJar(), createSourceJar(), run() +- publication (define information about module and artifacts to be published) | +- moduleId (group:name) | +- version | +- maven (maven specific information to be published in a Maven Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- mavenSpecificInfo | | +- methods : publish | +- ivy (Ivy specific information to be published in a Ivy Repositoty) | | +- dependencyCustomizer (customize the dependencies to be published) | | +- ivySpecifictInfo | | +- method : publish() | +- methods : publish(), getVersion(), getModuleId() + methods : getArtifacctPath(artifactName), toDependency(transitivity), getIdeSupport(), pack() For simplicity\u2019s sake, JkProject provides a facade in order to setup common settings friendly, without navigating deep into the structure. From facade, you can setup dependencies, java version, project layout, test behavior, test selection and publication. JkProject . of (). simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:21.0\" ) . and ( \"com.sun.jersey:jersey-server:1.19.4\" ) . and ( \"org.junit.jupiter:junit-jupiter-engine:5.6.0\" )) . configureRuntimeDeps ( deps -> deps . minus ( \"org.junit.jupiter:junit-jupiter-engine\" ) . and ( \"com.github.djeang:vincer-dom:1.2.0\" )) . configureTestDeps ( deps -> deps . and ( \"org.junit.vintage:junit-vintage-engine:5.6.0\" )) . addTestExcludeFilterSuffixedBy ( \"IT\" , false ) . setJavaVersion ( JkJavaVersion . V8 ) . setPublishedModuleId ( \"dev.jeka:sample-javaplugin\" ) . setPublishedVersion ( \"1.0-SNAPSHOT\" ); If facade is not sufficient for setting up project build, it's still possible to complete through the main API. JkProject instances are highly configurable. Here is a pretty complete example inspired from the Jeka Build Class .","title":"Project API"},{"location":"reference-guide/build-library/#third-party-tool-integration","text":"The dev.jeka.core.api.tooling package provides integration with tools developers generally deal with.","title":"Third Party Tool Integration"},{"location":"reference-guide/build-library/#eclipse","text":"JkEclipseClasspathGenerator and JkEclipseProjectGenerator provides method to generate a proper .classpath and .project file respectively. JkEclipseClasspathApplier reads information from a .classpath file.","title":"Eclipse"},{"location":"reference-guide/build-library/#intellij","text":"JkIntellijImlGenerator generates proper .iml files.","title":"Intellij"},{"location":"reference-guide/build-library/#git","text":"JkGitWrapper wraps common Git commands in a lean API.","title":"Git"},{"location":"reference-guide/build-library/#maven","text":"JkMvn wraps Maven command line in a lean API JkPom reads POM/BOM to extract information like : declared dependencies, dependency management, repos, properties, version and artifactId.","title":"Maven"},{"location":"reference-guide/execution-engine-defclasspath/","text":"Def classes \u00b6 Def classes are the compilation result of Java/Kotlin source files located in jeka/def . They can be declared at root or in sub-folders for packages. Execution engine compiles these files on the fly prior adding them to the Jeka classpath . It is possible to specify compilation options by annotating a def class as : @JkCompileOption ( \"-deprecation\" ) @JkCompileOption ({ \"-processorPath\" , \"/foo/bar\" }) class MyBuild { ... } Note jeka/def can also contain classpath resources. Classes having a name starting by _ are skipped from compilation. Java source files definded in def dir are compiled using the running JDK. Kotlin sources are compiled using Kotlin version specified by jeka.kotlin.version property if present or using Kotlin compiler specified by KOTLIN_HOME environment variable. Jeka Classpath \u00b6 Under the hood, Jeka simply executes Java byte code within a flat classloader. This classloader classpath is constructed from : jar files present in jeka/boot dir dependencies injected via command line and annotations compiled def classes Jeka classpaths coming from imported projects Injected Dependencies \u00b6 It's possible to inject transitively dependencies into classpath by either annotating def classes or by mentionning it in command line. Note By default, jeka fetch dependencies from maven central (https://repo.maven.apache.org/maven2). You can select another default repository by setting the jeka.repos.download.url options. We recommend storing this value in your [USER DIR]/.jeka/options.properties file to be reused across projects. For more details, see JkRepoFromOptions javadoc. Inject from Def Classes \u00b6 Annotate a def class with @JkInjectClasspath mentioning either a module coordinate or a path on the local file system. @JkInjectClasspath ( \"org.seleniumhq.selenium:selenium-remote-driver:4.0.0\" ) @JkInjectClasspath ( \"../libs/myutils.jar\" ) class MyBuild { ... } Note Update your IDE dependencies right after adding this annotation in order it can be used inside your def classes . jeka intellij#iml or jeka eclipse#files Warning Dependencies imported via @JkInjectClasspath are imported for all def classes and not only for annotated class. Inject from Command Line \u00b6 Specify path or module coordinates in the command line using '@' as @my.org:a-jeka-plugin:1.0.0 or @../libs/myutils.jar . This feature is meant to invoke KBeans dynamically. Imported Projects \u00b6 Jeka supports multi-module projects in Jeka classpath of a given project can include Jeka classpath of another one. @JkInjectProject ( \"../core\" ) class MyBuild { ... }","title":"Def-Classpath"},{"location":"reference-guide/execution-engine-defclasspath/#def-classes","text":"Def classes are the compilation result of Java/Kotlin source files located in jeka/def . They can be declared at root or in sub-folders for packages. Execution engine compiles these files on the fly prior adding them to the Jeka classpath . It is possible to specify compilation options by annotating a def class as : @JkCompileOption ( \"-deprecation\" ) @JkCompileOption ({ \"-processorPath\" , \"/foo/bar\" }) class MyBuild { ... } Note jeka/def can also contain classpath resources. Classes having a name starting by _ are skipped from compilation. Java source files definded in def dir are compiled using the running JDK. Kotlin sources are compiled using Kotlin version specified by jeka.kotlin.version property if present or using Kotlin compiler specified by KOTLIN_HOME environment variable.","title":"Def classes"},{"location":"reference-guide/execution-engine-defclasspath/#jeka-classpath","text":"Under the hood, Jeka simply executes Java byte code within a flat classloader. This classloader classpath is constructed from : jar files present in jeka/boot dir dependencies injected via command line and annotations compiled def classes Jeka classpaths coming from imported projects","title":"Jeka Classpath"},{"location":"reference-guide/execution-engine-defclasspath/#injected-dependencies","text":"It's possible to inject transitively dependencies into classpath by either annotating def classes or by mentionning it in command line. Note By default, jeka fetch dependencies from maven central (https://repo.maven.apache.org/maven2). You can select another default repository by setting the jeka.repos.download.url options. We recommend storing this value in your [USER DIR]/.jeka/options.properties file to be reused across projects. For more details, see JkRepoFromOptions javadoc.","title":"Injected Dependencies"},{"location":"reference-guide/execution-engine-defclasspath/#inject-from-def-classes","text":"Annotate a def class with @JkInjectClasspath mentioning either a module coordinate or a path on the local file system. @JkInjectClasspath ( \"org.seleniumhq.selenium:selenium-remote-driver:4.0.0\" ) @JkInjectClasspath ( \"../libs/myutils.jar\" ) class MyBuild { ... } Note Update your IDE dependencies right after adding this annotation in order it can be used inside your def classes . jeka intellij#iml or jeka eclipse#files Warning Dependencies imported via @JkInjectClasspath are imported for all def classes and not only for annotated class.","title":"Inject from Def Classes"},{"location":"reference-guide/execution-engine-defclasspath/#inject-from-command-line","text":"Specify path or module coordinates in the command line using '@' as @my.org:a-jeka-plugin:1.0.0 or @../libs/myutils.jar . This feature is meant to invoke KBeans dynamically.","title":"Inject from Command Line"},{"location":"reference-guide/execution-engine-defclasspath/#imported-projects","text":"Jeka supports multi-module projects in Jeka classpath of a given project can include Jeka classpath of another one. @JkInjectProject ( \"../core\" ) class MyBuild { ... }","title":"Imported Projects"},{"location":"reference-guide/execution-engine-files/","text":"The execution engine let to execute an arbitrary Java/Kotlin method from the command line or from an IDE. Methods are declared in regular Java/Kotlin classes. Build classes (called kbeans ) can be either defined as source file or provided as binary by external libs. Project Structure \u00b6 Every Jeka execution takes place in the context of a project. A Jeka project is a folder strucure containing a 'jeka' directory at its root. Execution must be launched from project root directory. All the following files or directories are optional except the jeka directory. Project Base Directory +- jekaw +- jekaw.bat +- jeka | +- local.properties | +- boot | | +- somelibs.jar | +- def | | +- SomeBuild.java | | +- SomeUtils.java | | +- ... | +- wrapper | | +- dev.jeka.core-wrapper.jar | | +- wrapper.properties | +- output | | +- ... | +- .work | | +- ... +- ... (project specific files like src/main/java, src/test/java, ...) Jeka Directory Content \u00b6 By convention, every project automated or built by Jeka contains a jeka directory at its root ( [Project Root]/jeka ). This directory contains everything Jeka needs to automate or build the project. In this directory, you may find : def (directory - optional) : User Java and/or Kotlin sources that will be executed by the execution engine. output (directory - generated) : Files produced by the tasks (jar files, classes, test reports, doc, ...) boot (directory - optional) : 3rd-party jar files users may add to be used by code located in def . wrapper (directory - optional) : Wrapper jar file for bootstrapping a specified version of Jeka. .work (directory - generated): Temp files generated by Jeka execution engine as compiled classes from def . These files are used as local cache to speed-up Jeka bootstraping and can be deleted safely. local.properties (file - optional) : Contains properties defined at project level, such as java version. Project root may also contain jekaw and jekaw.bat shell scripts to invoke Jeka wrapper conveniently. For the following, when we refer to the command jeka , you can use ./jekaw indifferently. All command lines are supposed to be launched from the root of the project (and not from [Project Root]/jeka ). Note When generating a project by scaffold mechanism, these files are created along self explanation inside their body. Jeka Wrapper \u00b6 Jeka wrapper consists in shell scripts, a thin booting jar and a configuration file in order Jeka can be executed on a specified version without being installed on the host machine. This is the recommended way of using Jeka as it makes builds portable from one machine to another. jekaw and jekaw.bat are respectively Unix like and Windows scripts to launch bootstrapping jar. jeka/wrapper/dev.jeka.core-wrapper.jar is the bootable jar in charge of downloading and installing the specified Jeka version on the host machine prior to launch Jeka jeka/wrapper/wrapper.properties specifies the Jeka version to use. When Jeka wrapper is installed on a project, execute jekaw instead of jeka . Jeka User Directory \u00b6 Jeka automatically creates a directory [User Home]/.jeka when running for the first time. This directory may contain : options.properties (file - optional) : Properties defined at global level (see later section). cache (directory - generated) : Various files cached by Jeka as downloaded files and specifically dependency artifacts. This directory can be safely deleted. maven_publish_dir (directory - generated) : Contains artifacts that your projects have published locally respecting Maven repository standards ivy_publish_dir (directory - generated) : Contains artifacts that your projects have published locally respecting Ivy repository standards In the contrary of Maven, Jeka does not publish locally on the same repository where are downloaded dependency artifacts.","title":"File Structure"},{"location":"reference-guide/execution-engine-files/#project-structure","text":"Every Jeka execution takes place in the context of a project. A Jeka project is a folder strucure containing a 'jeka' directory at its root. Execution must be launched from project root directory. All the following files or directories are optional except the jeka directory. Project Base Directory +- jekaw +- jekaw.bat +- jeka | +- local.properties | +- boot | | +- somelibs.jar | +- def | | +- SomeBuild.java | | +- SomeUtils.java | | +- ... | +- wrapper | | +- dev.jeka.core-wrapper.jar | | +- wrapper.properties | +- output | | +- ... | +- .work | | +- ... +- ... (project specific files like src/main/java, src/test/java, ...)","title":"Project Structure"},{"location":"reference-guide/execution-engine-files/#jeka-directory-content","text":"By convention, every project automated or built by Jeka contains a jeka directory at its root ( [Project Root]/jeka ). This directory contains everything Jeka needs to automate or build the project. In this directory, you may find : def (directory - optional) : User Java and/or Kotlin sources that will be executed by the execution engine. output (directory - generated) : Files produced by the tasks (jar files, classes, test reports, doc, ...) boot (directory - optional) : 3rd-party jar files users may add to be used by code located in def . wrapper (directory - optional) : Wrapper jar file for bootstrapping a specified version of Jeka. .work (directory - generated): Temp files generated by Jeka execution engine as compiled classes from def . These files are used as local cache to speed-up Jeka bootstraping and can be deleted safely. local.properties (file - optional) : Contains properties defined at project level, such as java version. Project root may also contain jekaw and jekaw.bat shell scripts to invoke Jeka wrapper conveniently. For the following, when we refer to the command jeka , you can use ./jekaw indifferently. All command lines are supposed to be launched from the root of the project (and not from [Project Root]/jeka ). Note When generating a project by scaffold mechanism, these files are created along self explanation inside their body.","title":"Jeka Directory Content"},{"location":"reference-guide/execution-engine-files/#jeka-wrapper","text":"Jeka wrapper consists in shell scripts, a thin booting jar and a configuration file in order Jeka can be executed on a specified version without being installed on the host machine. This is the recommended way of using Jeka as it makes builds portable from one machine to another. jekaw and jekaw.bat are respectively Unix like and Windows scripts to launch bootstrapping jar. jeka/wrapper/dev.jeka.core-wrapper.jar is the bootable jar in charge of downloading and installing the specified Jeka version on the host machine prior to launch Jeka jeka/wrapper/wrapper.properties specifies the Jeka version to use. When Jeka wrapper is installed on a project, execute jekaw instead of jeka .","title":"Jeka Wrapper"},{"location":"reference-guide/execution-engine-files/#jeka-user-directory","text":"Jeka automatically creates a directory [User Home]/.jeka when running for the first time. This directory may contain : options.properties (file - optional) : Properties defined at global level (see later section). cache (directory - generated) : Various files cached by Jeka as downloaded files and specifically dependency artifacts. This directory can be safely deleted. maven_publish_dir (directory - generated) : Contains artifacts that your projects have published locally respecting Maven repository standards ivy_publish_dir (directory - generated) : Contains artifacts that your projects have published locally respecting Ivy repository standards In the contrary of Maven, Jeka does not publish locally on the same repository where are downloaded dependency artifacts.","title":"Jeka User Directory"},{"location":"reference-guide/execution-engine-kbeans/","text":"KBeans \u00b6 KBean is the central concept of execution engine. KBeans are classes where are declared executable methods. There is only one KBean instance by KBean class in a given Jeka project. KBean classes share the following characteristics : Extend JkBean May declare public void methods taking no arguments. All these methods are invokable from command line. May declare public fields (aka KBean properties) . These field values can be injected from command line. They are supposed to be instantiated by the execution engine and not from user code. Simple Example \u00b6 The follwing KBeans exposes cleanPublish method which delegate the creation of jar files to the 'project' KBean. ProjectJkBean is available on Jeka classpath as it is part of the standard KBeans bundled in Jeka distribution. The configure method will be actually invoked at the first ProjectJkBean#getProject() call. import dev.jeka.core.api.project.JkProject ; @JkDoc ( \"A simple example to illustrate KBean concept.\" ) public class SimpleJkBean extends JkBean { ProjectJkBean projectBean = getBean ( ProjectJkBean . class ). configure ( this :: configure ); @JkDoc ( \"Version of junit-jupiter to use for compiling and running tests\" ) public String junitVersion = \"5.8.1\" ; private void configure ( JkProject project ) { project . simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:30.0-jre\" ) . and ( \"com.sun.jersey:jersey-server:1.19.4\" ) ) . configureTestDeps ( deps -> deps . and ( \"org.junit.jupiter:junit-jupiter:\" + junitVersion ) ); } @JkDoc ( \"Clean, compile, test and create jar files.\" ) public void cleanPack () { clean (); projectBean . pack (); } public static void main ( String [] args ) { JkInit . instanceOf ( SimpleProjectJkBean . class , args ). cleanPublish (); } } KBean Commands \u00b6 A KBean command is an instance method of a KBean class that can be invoked from command line. In order to be considered as a command , a method must : be public be an instance method take no argument return void KBean Properties \u00b6 A KBean property is a public instance field of a KBean class. Its value can be injected from command line. Fields can be annotated with @JkInjectProperty(\"my.prop.name\") to inject the value of a property in. For more details about field accepted types, see dev.jeka.core.tool.FieldInjector#parse method . KBean properties can also been nested composite objects, see example in ProjectJkBean#pack field . Naming KBeans \u00b6 In order to be referenced conveniently, KBeans accept to be called by a name. For a given JkBean class, ccepted names are : Full qualified class name Uncapitalized simple class name (e.g. 'myBuild' matches 'org.example.MyBuild') Uncapitalizes simple class Name without 'JkBean' suffix (.g. 'project' matches 'dev.jeka.core.tool.builtin.project.ProjectJkBean') Tip Execute jeka , at the root of a project to display KBeans present in Jeka classpath . Document KBeans \u00b6 KBean classes, methods and properties can be annotated with @JkDoc annotation in orderder to provide self documentation. Text within these annotations is displayed when invoking help method on console. Invoke KBeans \u00b6 From Command Line \u00b6 KBean methods can be invoked from command line using jeka [kbeanName]#methoName [kbeanName]#[propertyName]=xxx Many methods/properties can be invoked in a single command line. Info [kbeanName]# prefix can be omitted. By default, it will be resolved on the first KBean found in def dir. Search is made by fully qualified class name alphabetical order. From KBean main method \u00b6 KBean methods can also be launched/debugged from IDE. In KBean class, declare one or many main methods as : public static void main ( String [] args ) { JkInit . instanceOf ( MyBuild . class , args ). cleanPack (); } public static class Release { public static void main ( String [] args ) { JkInit . instanceOf ( MyBuild . class , args , \"-runIT\" ). release (); } } KBean must be instantiated using JkInit#instanceOf in order it be setup in proper state. The arguments passed in main method are interpreted as command line arguments. Launching or debugging this way is performant as all build classes and their dependencies are already on classpath. Therefore, no compilation or dependency resolution is needed. Warning Be careful to launch the main method using module dir as working dir . On IntelliJ , this is not the default (it uses project dir ). To change intelliJ defaults, follow : Edit Configurations | Edit configuration templates... | Application | Working Directory : $MODULE_DIR$ . From dev.jeka.core.tool.Main \u00b6 Sometimes, you may need to mimic closer the command line behavior, for debugging purpose or to pass '@' arguments. Create an IDE launcher for a Java Application Set dev.jeka.tool.Main as Java main class. Set the same command line arguments as you would do for invoking from command line (Do not include jeka command). Let KBeans cooperate \u00b6 Generally KBeans interact with each other inside their init method. They access each other using getRuntime().getBean(MyBean.class) as shown in this example . When a KBean depends on another one, it's good to declare it as an instance property of the first bean as this dependency will be mentioned in the auto-generated documentation. KBeans in Multi-Projects \u00b6 In multi-project build, it's quite common that a KBean accesses to a KBean instance coming from another project. You can achieve it in a statically typed way. In master KBean , declare a field of type JkBean (e.g. \u00b4JkBean importedBuild;`). It doesn't have to be public. Annotate it with @JkInjectProject mentioning the relative path of the imported project (e.g. `@JkInjectProject(\"../anotherModule\")). Execute jeka intellij#iml or jeka eclipse#files . Redefine the declared type from JkBean to the concrete type of imported KBean Now, master KBean can access the imported KBean in a static typed way. See example here . Be careful that the imported KBean deals with file paths using JkBean#getBaseDir in order it can be safely executed from any working directory. Standard KBeans \u00b6 There is a bunch of KBeans bundle within Jeka . Those KBeans are always present. project \u00b6 ProjectJkBean provides a wrapper around of a JkProject for building JVM-based projects. This KBean initialise a default sensitive project object and provides classic method for building project (compile, package in jar, publish ...) This KBean proposes extension point through its configure(JkProject) method. This way, other KBeans can modify the properties of the project to build. intellij \u00b6 IntellijJkBean provides methods for generating metadata files for IntelliJ IDE. Content of iml file is computed according the JkProject object found in project KBean . This KBean proposes extension point through its configure methods in order to modify the resulting iml (e.g. use a module dependency instead of a library dependency). scaffold \u00b6 ScaffoldjJkBean provides methods for project directories and files to create a new Jeka project. Basically, it creates a project ready to create vanilla automation tasks. This KBean offers extension point in order other KBean can augment the scaffolded structure. For example, executing jeka scaffold#run will create a basic Jeka project while jeka scaffold#run project# will create a project ready to build a JVM-based project. git \u00b6 GitJkBean exposes some common git command combos.","title":"KBeans"},{"location":"reference-guide/execution-engine-kbeans/#kbeans","text":"KBean is the central concept of execution engine. KBeans are classes where are declared executable methods. There is only one KBean instance by KBean class in a given Jeka project. KBean classes share the following characteristics : Extend JkBean May declare public void methods taking no arguments. All these methods are invokable from command line. May declare public fields (aka KBean properties) . These field values can be injected from command line. They are supposed to be instantiated by the execution engine and not from user code.","title":"KBeans"},{"location":"reference-guide/execution-engine-kbeans/#simple-example","text":"The follwing KBeans exposes cleanPublish method which delegate the creation of jar files to the 'project' KBean. ProjectJkBean is available on Jeka classpath as it is part of the standard KBeans bundled in Jeka distribution. The configure method will be actually invoked at the first ProjectJkBean#getProject() call. import dev.jeka.core.api.project.JkProject ; @JkDoc ( \"A simple example to illustrate KBean concept.\" ) public class SimpleJkBean extends JkBean { ProjectJkBean projectBean = getBean ( ProjectJkBean . class ). configure ( this :: configure ); @JkDoc ( \"Version of junit-jupiter to use for compiling and running tests\" ) public String junitVersion = \"5.8.1\" ; private void configure ( JkProject project ) { project . simpleFacade () . configureCompileDeps ( deps -> deps . and ( \"com.google.guava:guava:30.0-jre\" ) . and ( \"com.sun.jersey:jersey-server:1.19.4\" ) ) . configureTestDeps ( deps -> deps . and ( \"org.junit.jupiter:junit-jupiter:\" + junitVersion ) ); } @JkDoc ( \"Clean, compile, test and create jar files.\" ) public void cleanPack () { clean (); projectBean . pack (); } public static void main ( String [] args ) { JkInit . instanceOf ( SimpleProjectJkBean . class , args ). cleanPublish (); } }","title":"Simple Example"},{"location":"reference-guide/execution-engine-kbeans/#kbean-commands","text":"A KBean command is an instance method of a KBean class that can be invoked from command line. In order to be considered as a command , a method must : be public be an instance method take no argument return void","title":"KBean Commands"},{"location":"reference-guide/execution-engine-kbeans/#kbean-properties","text":"A KBean property is a public instance field of a KBean class. Its value can be injected from command line. Fields can be annotated with @JkInjectProperty(\"my.prop.name\") to inject the value of a property in. For more details about field accepted types, see dev.jeka.core.tool.FieldInjector#parse method . KBean properties can also been nested composite objects, see example in ProjectJkBean#pack field .","title":"KBean Properties"},{"location":"reference-guide/execution-engine-kbeans/#naming-kbeans","text":"In order to be referenced conveniently, KBeans accept to be called by a name. For a given JkBean class, ccepted names are : Full qualified class name Uncapitalized simple class name (e.g. 'myBuild' matches 'org.example.MyBuild') Uncapitalizes simple class Name without 'JkBean' suffix (.g. 'project' matches 'dev.jeka.core.tool.builtin.project.ProjectJkBean') Tip Execute jeka , at the root of a project to display KBeans present in Jeka classpath .","title":"Naming KBeans"},{"location":"reference-guide/execution-engine-kbeans/#document-kbeans","text":"KBean classes, methods and properties can be annotated with @JkDoc annotation in orderder to provide self documentation. Text within these annotations is displayed when invoking help method on console.","title":"Document KBeans"},{"location":"reference-guide/execution-engine-kbeans/#invoke-kbeans","text":"","title":"Invoke KBeans"},{"location":"reference-guide/execution-engine-kbeans/#from-command-line","text":"KBean methods can be invoked from command line using jeka [kbeanName]#methoName [kbeanName]#[propertyName]=xxx Many methods/properties can be invoked in a single command line. Info [kbeanName]# prefix can be omitted. By default, it will be resolved on the first KBean found in def dir. Search is made by fully qualified class name alphabetical order.","title":"From Command Line"},{"location":"reference-guide/execution-engine-kbeans/#from-kbean-main-method","text":"KBean methods can also be launched/debugged from IDE. In KBean class, declare one or many main methods as : public static void main ( String [] args ) { JkInit . instanceOf ( MyBuild . class , args ). cleanPack (); } public static class Release { public static void main ( String [] args ) { JkInit . instanceOf ( MyBuild . class , args , \"-runIT\" ). release (); } } KBean must be instantiated using JkInit#instanceOf in order it be setup in proper state. The arguments passed in main method are interpreted as command line arguments. Launching or debugging this way is performant as all build classes and their dependencies are already on classpath. Therefore, no compilation or dependency resolution is needed. Warning Be careful to launch the main method using module dir as working dir . On IntelliJ , this is not the default (it uses project dir ). To change intelliJ defaults, follow : Edit Configurations | Edit configuration templates... | Application | Working Directory : $MODULE_DIR$ .","title":"From KBean main method"},{"location":"reference-guide/execution-engine-kbeans/#from-devjekacoretoolmain","text":"Sometimes, you may need to mimic closer the command line behavior, for debugging purpose or to pass '@' arguments. Create an IDE launcher for a Java Application Set dev.jeka.tool.Main as Java main class. Set the same command line arguments as you would do for invoking from command line (Do not include jeka command).","title":"From dev.jeka.core.tool.Main"},{"location":"reference-guide/execution-engine-kbeans/#let-kbeans-cooperate","text":"Generally KBeans interact with each other inside their init method. They access each other using getRuntime().getBean(MyBean.class) as shown in this example . When a KBean depends on another one, it's good to declare it as an instance property of the first bean as this dependency will be mentioned in the auto-generated documentation.","title":"Let KBeans cooperate"},{"location":"reference-guide/execution-engine-kbeans/#kbeans-in-multi-projects","text":"In multi-project build, it's quite common that a KBean accesses to a KBean instance coming from another project. You can achieve it in a statically typed way. In master KBean , declare a field of type JkBean (e.g. \u00b4JkBean importedBuild;`). It doesn't have to be public. Annotate it with @JkInjectProject mentioning the relative path of the imported project (e.g. `@JkInjectProject(\"../anotherModule\")). Execute jeka intellij#iml or jeka eclipse#files . Redefine the declared type from JkBean to the concrete type of imported KBean Now, master KBean can access the imported KBean in a static typed way. See example here . Be careful that the imported KBean deals with file paths using JkBean#getBaseDir in order it can be safely executed from any working directory.","title":"KBeans in Multi-Projects"},{"location":"reference-guide/execution-engine-kbeans/#standard-kbeans","text":"There is a bunch of KBeans bundle within Jeka . Those KBeans are always present.","title":"Standard KBeans"},{"location":"reference-guide/execution-engine-kbeans/#project","text":"ProjectJkBean provides a wrapper around of a JkProject for building JVM-based projects. This KBean initialise a default sensitive project object and provides classic method for building project (compile, package in jar, publish ...) This KBean proposes extension point through its configure(JkProject) method. This way, other KBeans can modify the properties of the project to build.","title":"project"},{"location":"reference-guide/execution-engine-kbeans/#intellij","text":"IntellijJkBean provides methods for generating metadata files for IntelliJ IDE. Content of iml file is computed according the JkProject object found in project KBean . This KBean proposes extension point through its configure methods in order to modify the resulting iml (e.g. use a module dependency instead of a library dependency).","title":"intellij"},{"location":"reference-guide/execution-engine-kbeans/#scaffold","text":"ScaffoldjJkBean provides methods for project directories and files to create a new Jeka project. Basically, it creates a project ready to create vanilla automation tasks. This KBean offers extension point in order other KBean can augment the scaffolded structure. For example, executing jeka scaffold#run will create a basic Jeka project while jeka scaffold#run project# will create a project ready to build a JVM-based project.","title":"scaffold"},{"location":"reference-guide/execution-engine-kbeans/#git","text":"GitJkBean exposes some common git command combos.","title":"git"},{"location":"reference-guide/execution-engine-process/","text":"Jeka follows a specific process before invoking KBean methods : Parse command line and set system properties. Set working dir as [project dir] Augment the current classloader with jar files found in [project dir]/jeka/boot Parses source files contained in project dir/jeka/def Detect @JkInjectProject annotations. For each : Set [project dir] to value declared in annotation Process steps 3, 4, 5, 6 for the injected project Augment the current classloader with dependencies declared in source files Compile files in [project dir]/def/jeka and augment current classloader with compiled files If compilation fail and command-line option -dci is present, ignore it. Scan classloader classpath to find KBeans and associate each KBean referenced in command line Identify the default KBean if any. The default KBean is the first class found in [project dir]/jeka/def extending JkBean . Instantiate the default KBean . Instantiate means : Invoke no-arg constructor Inject KBean properties mentioned in command line Instantiate other KBean , if not yet done by order they appear in command line. Once KBeans have been instantiated, KBean methods are executed in order they appear in the command line. Info There is only one KBean instance by KBean class and by project. Info JkRuntime is the KBean container for a given project. Each KBean instance belongs to a JkRuntime . From JkRuntime , you can access to other KBeans from same or other projects.","title":"Process"},{"location":"reference-guide/execution-engine-properties/","text":"Properties \u00b6 Properties are pairs of String key-value that are used across Jeka system. It typically carries urls, local paths, tool versions or credentials. Properties can be defined at different level, in order of precedence : System properties : Properties can be defined using system properties as -DpropertyName=value . System properties can be injected from Jeka command line. OS environment variables : Properties can also be defined as OS environment variable. Project : Defined in [Project Root]/jeka/local.properties . Used typically for storing tool version (e.g. jeka.kotlin.version=1.5.21 ). Global : Defined in [User Home]/.jeka/global.properties file. Used typically to define urls, local paths and credentials. Properties inherit from project properties defined in project parent folders (if exists). Here, project2 will inherit properties defined in project1/jeka/local.properties : project1 + jeka + local.properties + project2 (sub-project) + jeka + local.properties Info Properties support interpolation via ${} tokens. For example, if we define the following properties : foo=fooValue and bar=bar ${foo} then JkProperties.get(\"bar\") will return 'bar fooValue'. Standard properties \u00b6 jeka.jdk.X= location of the JDK version X (e.g. jeka.jdk.11=/my/java/jdk11) . It is used to compile projects when project JVM target version differs from Jeka running version. jeka.kotlin.version : Version of Kotlin used for compiling both def and Kotlin project sources. jeka.java.version : Target JVM version for compiled files. Command shorthands \u00b6 jeka.cmd.xxx= define an alias that can be substituted to its value in the command line using : symbol. Example : jeka.cmd.myBuild=${jeka.cmd.build} sonarqube#run jacoco# lets to simply execute jeka :myBuild . jeka.cmd._append= will append the argument to every Jeka execution command. Example : jeka.cmd._append=@dev.jeka:springboot-plugin will add springboot plugin to Jeka classpath for each execution. Note Command shorthands is a really powerful mechanism to get rid of build classes. Many projects can be builds using properties only ! Repositories \u00b6 The repositories used to download and publish artifacts can be defined using properties . The download repositories are set using jeka.repos.download property, while publish repository is defined using jeka.repos.publish . Use JkRepoFromProperties class to get the repositories defined by properties . Note By default, when no repository is configured, artifacts are downloaded on Maven Central repo. Using single repo jeka.repos.download=https://my.company/repo Using multiple repos jeka.repos.download=https://my.company/repo1, file://path/to/a/local/repo Using single repo with credential jeka.repos.download=https://my.company/repo jeka.repos.download.username=myUsername jeka.repos.download.password=myPassword For convenience, we can define multiple repositories and reference them using aliases jeka.repos.myRepo1=https://my.company/repo jeka.repos.myRepo1.username=myUsername jeka.repos.myRepo1.password=myPassword jeka.repos.myRepo2=https://my.company/repo2 jeka.repos.myRepo2.username=myUsername2 jeka.repos.myRepo2.password=myPassword2 jeka.repos.download=myRepo1, myRepo2 jeka.repos.publish=myRepo2 Aliases are predefined for Maven Central and Jeka GitHub Repos jeka.repos.download=https://my.company/repo1, mavenCentral, jekaGithub jeka.repos.jekaGithub.username=myGithubAccountName jeka.repos.jekaGithub.password=myGithubPersonalAccessToken KBean field value injection \u00b6 If a property is named as xxx#yyyyy then Jeka will try to inject its value in public field yyyyy of KBean xxx . examples: springboot#springbootVersion=2.4.7 project#test.skip=true Note There is a slight difference between using -Dproject#test.skip=true and project#test.skip=true on the command line. For the first, field is injected via system properties, this means that for multi-modules projects, the value will be injected on every Jeka module. While for the second, the value will be injected only on the root module.","title":"Properties"},{"location":"reference-guide/execution-engine-properties/#properties","text":"Properties are pairs of String key-value that are used across Jeka system. It typically carries urls, local paths, tool versions or credentials. Properties can be defined at different level, in order of precedence : System properties : Properties can be defined using system properties as -DpropertyName=value . System properties can be injected from Jeka command line. OS environment variables : Properties can also be defined as OS environment variable. Project : Defined in [Project Root]/jeka/local.properties . Used typically for storing tool version (e.g. jeka.kotlin.version=1.5.21 ). Global : Defined in [User Home]/.jeka/global.properties file. Used typically to define urls, local paths and credentials. Properties inherit from project properties defined in project parent folders (if exists). Here, project2 will inherit properties defined in project1/jeka/local.properties : project1 + jeka + local.properties + project2 (sub-project) + jeka + local.properties Info Properties support interpolation via ${} tokens. For example, if we define the following properties : foo=fooValue and bar=bar ${foo} then JkProperties.get(\"bar\") will return 'bar fooValue'.","title":"Properties"},{"location":"reference-guide/execution-engine-properties/#standard-properties","text":"jeka.jdk.X= location of the JDK version X (e.g. jeka.jdk.11=/my/java/jdk11) . It is used to compile projects when project JVM target version differs from Jeka running version. jeka.kotlin.version : Version of Kotlin used for compiling both def and Kotlin project sources. jeka.java.version : Target JVM version for compiled files.","title":"Standard properties"},{"location":"reference-guide/execution-engine-properties/#command-shorthands","text":"jeka.cmd.xxx= define an alias that can be substituted to its value in the command line using : symbol. Example : jeka.cmd.myBuild=${jeka.cmd.build} sonarqube#run jacoco# lets to simply execute jeka :myBuild . jeka.cmd._append= will append the argument to every Jeka execution command. Example : jeka.cmd._append=@dev.jeka:springboot-plugin will add springboot plugin to Jeka classpath for each execution. Note Command shorthands is a really powerful mechanism to get rid of build classes. Many projects can be builds using properties only !","title":"Command shorthands"},{"location":"reference-guide/execution-engine-properties/#repositories","text":"The repositories used to download and publish artifacts can be defined using properties . The download repositories are set using jeka.repos.download property, while publish repository is defined using jeka.repos.publish . Use JkRepoFromProperties class to get the repositories defined by properties . Note By default, when no repository is configured, artifacts are downloaded on Maven Central repo. Using single repo jeka.repos.download=https://my.company/repo Using multiple repos jeka.repos.download=https://my.company/repo1, file://path/to/a/local/repo Using single repo with credential jeka.repos.download=https://my.company/repo jeka.repos.download.username=myUsername jeka.repos.download.password=myPassword For convenience, we can define multiple repositories and reference them using aliases jeka.repos.myRepo1=https://my.company/repo jeka.repos.myRepo1.username=myUsername jeka.repos.myRepo1.password=myPassword jeka.repos.myRepo2=https://my.company/repo2 jeka.repos.myRepo2.username=myUsername2 jeka.repos.myRepo2.password=myPassword2 jeka.repos.download=myRepo1, myRepo2 jeka.repos.publish=myRepo2 Aliases are predefined for Maven Central and Jeka GitHub Repos jeka.repos.download=https://my.company/repo1, mavenCentral, jekaGithub jeka.repos.jekaGithub.username=myGithubAccountName jeka.repos.jekaGithub.password=myGithubPersonalAccessToken","title":"Repositories"},{"location":"reference-guide/execution-engine-properties/#kbean-field-value-injection","text":"If a property is named as xxx#yyyyy then Jeka will try to inject its value in public field yyyyy of KBean xxx . examples: springboot#springbootVersion=2.4.7 project#test.skip=true Note There is a slight difference between using -Dproject#test.skip=true and project#test.skip=true on the command line. For the first, field is injected via system properties, this means that for multi-modules projects, the value will be injected on every Jeka module. While for the second, the value will be injected only on the root module.","title":"KBean field value injection"},{"location":"reference-guide/execution-engine-reuse/","text":"Jeka provides powerful and easy means to reuse build elements across projects. Elements can be reused as sources in a multi-project structure or exported as binaries in order to be used as third-party dependencies to create a plugin ecosystem. From Sources \u00b6 In a multi-project (aka multi-module project), it is possible to use classes defined in other sub-projects. When using @JkInjectProject , classes defined in ../sub-project-1/jeka/def and in the classpath of sub-project-1 . import dev.jeka.core.tool.JkBean ; @JkInjectProject ( \"../sub-project\" ) class MyJkBean extends JkBean { } In a KBean , it is possible to use a KBean coming from another project. import dev.jeka.core.tool.JkBean ; class MyJkBean extends JkBean { @JkInjectProject ( \"../sub-project\" ) private OtherJkBean importedBean ; } From Binaries \u00b6 To extend Jeka capabilities, it's possible to create a jar file in order to be used in any Jeka project. An extension (or plugin) can contain KBean or not and can have many purposes (integrate a specific technology, predefine set of dependencies, provide utiliy classes, ...). To achieve it, we need to create a project to pack and export the library. The project may declare dependencies on Jeka : the simplest is to add a dependency on the jeka jar that is actually building the project using JkLocator.getJekaJarPath() . import dev.jeka.core.api.project.JkProject ; class Build extends JkBean { ProjectJkBean projectBean = getBean ( ProjectJkean . class ). configure ( this :: configure ); private void configure ( JkProject project ) { // Optional indication about Jeka version compatibility JkJekaVersionCompatibilityChecker . setCompatibilityRange ( project . getConstruction (). getManifest (), \"0.9.20.RC2\" , \"https://raw.githubusercontent.com/jerkar/protobuf-plugin/breaking_versions.txt\" ); project . simpleFacade () . configureCompileDeps ( deps -> deps . andFiles ( JkLocator . getJekaJarPath ()) ); } } Check Jeka Version Compatibility \u00b6 JkJekaVersionCompatibilityChecker.setCompatibilityRange insert information about Jeka version compatibility within the Manifest. This information will be used by Jeka to alert if the library is marked as incompatible with the running Jeka version. The method take 3 arguments : The object standing for the Manifest file The lowest version of Jeka which is compatible with the library An url string pointing on a file mentioning the versions of Jeka that are no longer compatible with the version of the library For the last, the information has to be stored outside the library itself as the author can not guess which future version of Jeka will break the compatibility. An example of such a file is available here","title":"Reuse Elements"},{"location":"reference-guide/execution-engine-reuse/#from-sources","text":"In a multi-project (aka multi-module project), it is possible to use classes defined in other sub-projects. When using @JkInjectProject , classes defined in ../sub-project-1/jeka/def and in the classpath of sub-project-1 . import dev.jeka.core.tool.JkBean ; @JkInjectProject ( \"../sub-project\" ) class MyJkBean extends JkBean { } In a KBean , it is possible to use a KBean coming from another project. import dev.jeka.core.tool.JkBean ; class MyJkBean extends JkBean { @JkInjectProject ( \"../sub-project\" ) private OtherJkBean importedBean ; }","title":"From Sources"},{"location":"reference-guide/execution-engine-reuse/#from-binaries","text":"To extend Jeka capabilities, it's possible to create a jar file in order to be used in any Jeka project. An extension (or plugin) can contain KBean or not and can have many purposes (integrate a specific technology, predefine set of dependencies, provide utiliy classes, ...). To achieve it, we need to create a project to pack and export the library. The project may declare dependencies on Jeka : the simplest is to add a dependency on the jeka jar that is actually building the project using JkLocator.getJekaJarPath() . import dev.jeka.core.api.project.JkProject ; class Build extends JkBean { ProjectJkBean projectBean = getBean ( ProjectJkean . class ). configure ( this :: configure ); private void configure ( JkProject project ) { // Optional indication about Jeka version compatibility JkJekaVersionCompatibilityChecker . setCompatibilityRange ( project . getConstruction (). getManifest (), \"0.9.20.RC2\" , \"https://raw.githubusercontent.com/jerkar/protobuf-plugin/breaking_versions.txt\" ); project . simpleFacade () . configureCompileDeps ( deps -> deps . andFiles ( JkLocator . getJekaJarPath ()) ); } }","title":"From Binaries"},{"location":"reference-guide/execution-engine-reuse/#check-jeka-version-compatibility","text":"JkJekaVersionCompatibilityChecker.setCompatibilityRange insert information about Jeka version compatibility within the Manifest. This information will be used by Jeka to alert if the library is marked as incompatible with the running Jeka version. The method take 3 arguments : The object standing for the Manifest file The lowest version of Jeka which is compatible with the library An url string pointing on a file mentioning the versions of Jeka that are no longer compatible with the version of the library For the last, the information has to be stored outside the library itself as the author can not guess which future version of Jeka will break the compatibility. An example of such a file is available here","title":"Check Jeka Version Compatibility"},{"location":"reference-guide/execution-engine-setup/","text":"You need a JDK 8 or higher installed on your machine. To determine the JDK to run upon, jeka looks in priority order : JEKA_JDK environment variable ([ JEKA_JDK ]/bin/java must point on java executable) JAVA_HOME environment variable java executable accessible from PATH environment variable. Note Jeka organization provides a plugin for IntelliJ in order to make the following tasks useless. Here, we'll focus only on how to do it using command line only. There are two ways of using jeka : by installing Jeka itself or by using a project already containing the Jeka wrapper. Install Jeka Distribution \u00b6 Note It is not required to install Jeka distribution to use it. If you fetch a project already holding a wrapper, using jekaw would be enough. Nevertheless, if you want to create project from scractch, it will be required. Download the latest release from here and unpack the distrib.zip wherever you want on your machine. We'll refer to this directory as [JEKA HOME]. Add [JEKA HOME] to your PATH environment variable. Now, you can use jeka command from everywhere. Projects with Jeka Wrapper \u00b6 For working on a project already holding a Jeka wrapper, there is no need to install Jeka : Fetch the project from its remote repository Use jekaw command from project root path. Note To start from an empty project, clone template blank project from https://github.com/jerkar/jeka-wrapper-project-template.git Setup IDE \u00b6 Add an IDE path variable JEKA_USER_HOME pointing on [USER HOME]/.jeka . In Intellij : Settings... | Appearance & Behavior | Path Variables If you use jeka instead of jekaw , add an IDE path variable JEKA_HOME pointing on [JEKA HOME]. Hello World Project \u00b6 For simplicity's sake, we'll use trivial example just displaying a message on console. Create Project Structure \u00b6 Create the root dir of the project or use the template wrapper project mentioned above. At project root, execute jeka scaffold#run scaffold#wrapper (or just jekaw scaffold#run if using the template wrapper project). Execute jeka intellij#iml or jeka eclipse#files in order to generate IDE configuration file. The project with a Jeka structure and a basic build class is ready to work within your IDE Create a Jeka Method \u00b6 Jeka methods require to be zero-args instance methods returning void . Modify the def/Build.java file to ad hello method as follow. import dev.jeka.core.tool.JkBean ; import dev.jeka.core.tool.JkInit ; class Build extends JkBean { public void hello () { System . out . println ( \"Hello world !\" ); } public static void main ( String [] args ) throws Exception { Build build = JkInit . instanceOf ( Build . class , args ); build . hello (); } } Now, execute jeka hello to see message displayed on console. Optionally, we can use a classical main method to launch it from the IDE. Get Contextual Help \u00b6 Execute jeka -h (or jeka -help ) to display a contextual help on the console. Follow instructions to navigate to more specific help context. Warning Do not confuse jeka -help and jeka help . The last provides only documentation about the default KBean . Customization \u00b6 For any reasons, we might use different location than the standard ones for Jeka User Home and Jeka Cache . We can change the location using following OS environment variable : JEKA_USER_HOME : to set the Jeka User Home to a specified location (absolute path). JEKA_CACHE_DIR : to set the cache (mainly all downloaded files), to a specified location (absolute path)","title":"Setup"},{"location":"reference-guide/execution-engine-setup/#install-jeka-distribution","text":"Note It is not required to install Jeka distribution to use it. If you fetch a project already holding a wrapper, using jekaw would be enough. Nevertheless, if you want to create project from scractch, it will be required. Download the latest release from here and unpack the distrib.zip wherever you want on your machine. We'll refer to this directory as [JEKA HOME]. Add [JEKA HOME] to your PATH environment variable. Now, you can use jeka command from everywhere.","title":"Install Jeka Distribution"},{"location":"reference-guide/execution-engine-setup/#projects-with-jeka-wrapper","text":"For working on a project already holding a Jeka wrapper, there is no need to install Jeka : Fetch the project from its remote repository Use jekaw command from project root path. Note To start from an empty project, clone template blank project from https://github.com/jerkar/jeka-wrapper-project-template.git","title":"Projects with Jeka Wrapper"},{"location":"reference-guide/execution-engine-setup/#setup-ide","text":"Add an IDE path variable JEKA_USER_HOME pointing on [USER HOME]/.jeka . In Intellij : Settings... | Appearance & Behavior | Path Variables If you use jeka instead of jekaw , add an IDE path variable JEKA_HOME pointing on [JEKA HOME].","title":"Setup IDE"},{"location":"reference-guide/execution-engine-setup/#hello-world-project","text":"For simplicity's sake, we'll use trivial example just displaying a message on console.","title":"Hello World Project"},{"location":"reference-guide/execution-engine-setup/#create-project-structure","text":"Create the root dir of the project or use the template wrapper project mentioned above. At project root, execute jeka scaffold#run scaffold#wrapper (or just jekaw scaffold#run if using the template wrapper project). Execute jeka intellij#iml or jeka eclipse#files in order to generate IDE configuration file. The project with a Jeka structure and a basic build class is ready to work within your IDE","title":"Create Project Structure"},{"location":"reference-guide/execution-engine-setup/#create-a-jeka-method","text":"Jeka methods require to be zero-args instance methods returning void . Modify the def/Build.java file to ad hello method as follow. import dev.jeka.core.tool.JkBean ; import dev.jeka.core.tool.JkInit ; class Build extends JkBean { public void hello () { System . out . println ( \"Hello world !\" ); } public static void main ( String [] args ) throws Exception { Build build = JkInit . instanceOf ( Build . class , args ); build . hello (); } } Now, execute jeka hello to see message displayed on console. Optionally, we can use a classical main method to launch it from the IDE.","title":"Create a Jeka Method"},{"location":"reference-guide/execution-engine-setup/#get-contextual-help","text":"Execute jeka -h (or jeka -help ) to display a contextual help on the console. Follow instructions to navigate to more specific help context. Warning Do not confuse jeka -help and jeka help . The last provides only documentation about the default KBean .","title":"Get Contextual Help"},{"location":"reference-guide/execution-engine-setup/#customization","text":"For any reasons, we might use different location than the standard ones for Jeka User Home and Jeka Cache . We can change the location using following OS environment variable : JEKA_USER_HOME : to set the Jeka User Home to a specified location (absolute path). JEKA_CACHE_DIR : to set the cache (mainly all downloaded files), to a specified location (absolute path)","title":"Customization"},{"location":"tutorials/gui-getting-started/","text":"Getting started with Jeka \u00b6 Install Intellij Plugin \u00b6 Install plugin directly from here or search jeka in Intellij Marketplace. As this plugin embeds its own version of Jeka , that's all we need to install on our machine. Hello World ! \u00b6 The below example showcases how to write tasks executable both from IDE and command line. Create a new Jeka project in Intellij : New > Project ... > Jeka Leave default (we might change the name) and press Create . Note Jeka structure (folders and files) can be created on an existing project from any type. On IntelliJ project window-tool : Select project > Click Left > Jeka ... > Scaffold ... We get a workable Jeka project from we can : execute/debug methods from the IDE using editor gutter buttons or tool-windows explorer. navigate to discover available KBeans on this project, and their content. create Intellij run-configuration from existing methods execute methods directly in the terminal (e.g. ./jekaw hello name=Joe ) create new methods/fields. If they do not appear on tool-window, use top menu button to refresh view. Import 3rd Party libraries \u00b6 We can also import 3rd-party libraries to use in our build classes by using @JkInjectClasspath annotation. Libraries referenced with coordinates will come into classpath along all their dependencies. Do not forget to refresh iml explicitly when Jeka classpath has been changed. Tip Use Ctrl+space when editing @JkInjectClasspath to get dependency auto-completion. Build a Java Project \u00b6 Create a new Jeka project in Intellij : New > Project ... > Jeka Select java project template and click Create We get a workable Java project. Now we can : Add dependencies using project.flatFacade().configureXxxDependencies() in Build class. Add dependencies by editing project-dependencies.txt file Customize project instance in order it fits our need. After modifying your dependencies, do not forget to refresh Intellij by Right Click > Jeka Synchronise Iml File Our project is ready to code. Invoke cleanPack to generate binary, sources and javadoc jar files. Tip Navigate to the right-side Jeka Tool Window > Classpath KBeans > project to see all available methods. Right-click on a methods to run/debug it from IDE. It is possible to combine several methods using Run... or Debug... For most standard project, we may not need build code, only simple properties file. To scaffold such a project : Create a new Jeka project in Intellij : New > Project ... > Jeka Select java project - code.less template and click Create We get : Execute ./jekaw :build_quality to make a full build and perform Sonarqube analysis + code coverage. Properties and code can be used in conjunction, tough build class may override values defined in local.properties . We will find many project examples here Learn more about Java project builds Learn more about dependency management Build a Springboot Project \u00b6 Create a new Jeka project in Intellij : New > Project ... > Jeka Select springboot project template and click Create We get a project ready to code containing already a workable RestController and its test counterpart. Execute ./jekaw project#pack to generate the bootable jar. Execute ./jekaw project#runJar to run the bootable.jar Note As for java project , Springbooty projects can be scaffolded with code.less flavor.","title":"Getting Started"},{"location":"tutorials/gui-getting-started/#getting-started-with-jeka","text":"","title":"Getting started with Jeka"},{"location":"tutorials/gui-getting-started/#install-intellij-plugin","text":"Install plugin directly from here or search jeka in Intellij Marketplace. As this plugin embeds its own version of Jeka , that's all we need to install on our machine.","title":"Install Intellij Plugin "},{"location":"tutorials/gui-getting-started/#hello-world","text":"The below example showcases how to write tasks executable both from IDE and command line. Create a new Jeka project in Intellij : New > Project ... > Jeka Leave default (we might change the name) and press Create . Note Jeka structure (folders and files) can be created on an existing project from any type. On IntelliJ project window-tool : Select project > Click Left > Jeka ... > Scaffold ... We get a workable Jeka project from we can : execute/debug methods from the IDE using editor gutter buttons or tool-windows explorer. navigate to discover available KBeans on this project, and their content. create Intellij run-configuration from existing methods execute methods directly in the terminal (e.g. ./jekaw hello name=Joe ) create new methods/fields. If they do not appear on tool-window, use top menu button to refresh view.","title":"Hello World ! "},{"location":"tutorials/gui-getting-started/#import-3rd-party-libraries","text":"We can also import 3rd-party libraries to use in our build classes by using @JkInjectClasspath annotation. Libraries referenced with coordinates will come into classpath along all their dependencies. Do not forget to refresh iml explicitly when Jeka classpath has been changed. Tip Use Ctrl+space when editing @JkInjectClasspath to get dependency auto-completion.","title":"Import 3rd Party libraries "},{"location":"tutorials/gui-getting-started/#build-a-java-project","text":"Create a new Jeka project in Intellij : New > Project ... > Jeka Select java project template and click Create We get a workable Java project. Now we can : Add dependencies using project.flatFacade().configureXxxDependencies() in Build class. Add dependencies by editing project-dependencies.txt file Customize project instance in order it fits our need. After modifying your dependencies, do not forget to refresh Intellij by Right Click > Jeka Synchronise Iml File Our project is ready to code. Invoke cleanPack to generate binary, sources and javadoc jar files. Tip Navigate to the right-side Jeka Tool Window > Classpath KBeans > project to see all available methods. Right-click on a methods to run/debug it from IDE. It is possible to combine several methods using Run... or Debug... For most standard project, we may not need build code, only simple properties file. To scaffold such a project : Create a new Jeka project in Intellij : New > Project ... > Jeka Select java project - code.less template and click Create We get : Execute ./jekaw :build_quality to make a full build and perform Sonarqube analysis + code coverage. Properties and code can be used in conjunction, tough build class may override values defined in local.properties . We will find many project examples here Learn more about Java project builds Learn more about dependency management","title":"Build a Java Project"},{"location":"tutorials/gui-getting-started/#build-a-springboot-project","text":"Create a new Jeka project in Intellij : New > Project ... > Jeka Select springboot project template and click Create We get a project ready to code containing already a workable RestController and its test counterpart. Execute ./jekaw project#pack to generate the bootable jar. Execute ./jekaw project#runJar to run the bootable.jar Note As for java project , Springbooty projects can be scaffolded with code.less flavor.","title":"Build a Springboot Project "},{"location":"tutorials/gui-reuse-elements/","text":"Reuse build logic (Work in progress) \u00b6 Jeka offers flexible and powerful mechanisms to reuse build logic, as : Adding Java dependencies to def classpath. Importing build code from another module (see example here ) Using plugins Add dependencies to def classpath \u00b6 This simple mechanism is powerful. It let def classes depend on other Java code just as it would be for test/production code. It means that def classes can depend on : code lying in a different module from the same multi-module project compiled code lying somewhere on filesystem jars located in a binary repository (i.e. Maven modules) This tutorial will give some simple examples on how you can factor out parts of your builds. With Jeka you can reuse and share any build elements exactly as you would do for regular code. You can reuse piece of code within a multi-module project or export it on a repository to reuse it across projects. These piece of code can be Jeka plugins or simple classes for make your build code shorter, tough you can much smarter thing Create your own plugin \u00b6 A plugin is a collection of commands and options (meaning public no-args methods and fields) that can be bind to any JkClass in order to augment it or modify its behavior. For common usage, you don't need to write your own plugin but you will probably uses the ones that are bundled with Jeka. The simplest think to understand how it works, is to write your own one.","title":"Reuse Elements"},{"location":"tutorials/gui-reuse-elements/#reuse-build-logic-work-in-progress","text":"Jeka offers flexible and powerful mechanisms to reuse build logic, as : Adding Java dependencies to def classpath. Importing build code from another module (see example here ) Using plugins","title":"Reuse build logic (Work in progress)"},{"location":"tutorials/gui-reuse-elements/#add-dependencies-to-def-classpath","text":"This simple mechanism is powerful. It let def classes depend on other Java code just as it would be for test/production code. It means that def classes can depend on : code lying in a different module from the same multi-module project compiled code lying somewhere on filesystem jars located in a binary repository (i.e. Maven modules) This tutorial will give some simple examples on how you can factor out parts of your builds. With Jeka you can reuse and share any build elements exactly as you would do for regular code. You can reuse piece of code within a multi-module project or export it on a repository to reuse it across projects. These piece of code can be Jeka plugins or simple classes for make your build code shorter, tough you can much smarter thing","title":"Add dependencies to def classpath"},{"location":"tutorials/gui-reuse-elements/#create-your-own-plugin","text":"A plugin is a collection of commands and options (meaning public no-args methods and fields) that can be bind to any JkClass in order to augment it or modify its behavior. For common usage, you don't need to write your own plugin but you will probably uses the ones that are bundled with Jeka. The simplest think to understand how it works, is to write your own one.","title":"Create your own plugin"}]}